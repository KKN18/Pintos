<!DOCTYPE html>
<!-- saved from url=(0057)http://www.cnblogs.com/laiy/p/pintos_project1_thread.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script async="" src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/analytics.js"></script><script async="" src="http://ad.cnblogs.com/ad/postmoduletext?callback=jQuery17022281857463531196_1432084034635&adModuleId=2&content=Pintos-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FProject%E8%AF%A6%E8%A7%A3-Project1&_=1432084035331"></script>
<meta charset="utf-8">
<title>Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园</title>
<link type="text/css" rel="stylesheet" href="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/bundle-darkgreentrip.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/laiy/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/laiy/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/laiy/wlwmanifest.xml">
<script type="text/javascript" src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/encoder.js"></script><script async="" type="text/javascript" src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/gpt.js"></script><script src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/jquery.js" type="text/javascript"></script><style type="text/css"></style><style type="text/css"></style>  
<script type="text/javascript">var currentBlogApp = 'laiy', cb_enable_mathjax=false;</script>
<script src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/blog-common.js" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="http://www.cnblogs.com/laiy/"><img id="blogLogo" src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/logo.gif" alt="返回主页"></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/laiy/">laiy</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li><a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/laiy/">首页</a></li>
<li><a id="MyLinks1_NewPostLink" class="menu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="MyLinks1_ContactLink" class="menu" rel="nofollow" href="http://space.cnblogs.com/msg/send/laiy">联系</a></li>
<li><a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/laiy/rss">订阅</a>
<!--<a id="MyLinks1_XMLLink" class="aHeaderXML" href="http://www.cnblogs.com/laiy/rss"><img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			
<!--done-->
随笔- 3&nbsp;
文章- 0&nbsp;
评论- 2&nbsp;

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		

<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园.html">Pintos-斯坦福大学操作系统Project详解-Project1</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body"><p><span style="color: #ff0000;">&nbsp;转载请注明出处。</span></p>
<p><span style="font-size: 18pt;"><strong>前言</strong><strong>：&nbsp;</strong></span></p>
<p><span style="font-size: 18pt;"><strong><span style="font-size: 16px;">本实验来自斯坦福大学<span style="color: #000000;"><span style="color: #000000;">cs140课程</span>，只限</span>于教学用途，以下是他们对于Pintos系统的介绍：</span>&nbsp;</strong></span></p>
<blockquote>
<p><strong>Pintos is a simple operating system framework for the 80x86 architecture. It supports kernel threads, loading and running user programs, and a file system, but it implements all of these in a very simple way. In the Pintos projects, you and your project team will strengthen its support in all three of these areas. You will also add a virtual memory implementation.</strong></p>
</blockquote>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">Pintos实验主要分成四部分，如下所示：</span></p>
<ul>
<li><span style="font-size: 16px;">实验一：Thread</span></li>
<li><span style="font-size: 16px;">实验二：User Programs</span></li>
<li><span style="font-size: 16px;">实验三：Virtual Memory</span></li>
<li><span style="font-size: 16px;">实验四：File System</span></li>
</ul>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">实验原理：</span></strong></p>
<p><span style="font-size: 16px;">通过 bochs 加载 pintos 操作系统， 该操作系统会根据 pintos 的实现打印运行结果，通过比较标准输出文档和实际输出，来判断 pintos 实现是否符合要求。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">环境配置：</span></strong></p>
<blockquote>
<p><span style="font-size: 16px;"><span style="line-height: 36px;"><strong>参考： http://www.stanford.edu/class/cs140/projects/pintos/pintos_12.html#SEC166</strong></span></span></p>
</blockquote>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong style="line-height: 1.5;">实验实现代码地址：</strong></span></p>
<blockquote>
<p><span style="font-size: 16px;">&nbsp;<strong>https://github.com/laiy/Pintos/tree/master/src</strong></span></p>
</blockquote>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong style="line-height: 1.5;">实验一 THREAD：</strong></span></p>
<p><span style="font-size: 16px;">我们试验一的最终任务就是在threads/中跑make check的时候， 27个test全pass。</span></p>
<p><span style="font-size: 18pt;"><strong>Mission1:</strong></span></p>
<p><span style="font-size: 14pt;"><strong><span style="color: #ff0000;">重新实现<code>timer_sleep</code>函数（2.2.2）</span></strong></span></p>
<p><span style="font-size: 14pt;"><strong><span style="color: #ff0000;">（注意， 博主以下用了包括代码在内大概7000字的说明从每一个底层细节解析了这个函数的执行， 虽然很长但是让我们对pintos这个操作系统的各种机制和实现有更深刻的理解， 如果嫌长请直接跳到<a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#timer_sleep">函数重新实现</a>）</span></strong></span></p>
<p><span style="font-size: 18px; color: #ff0000;"><strong><span style="font-size: 16px; color: #000000;"><code>timer_sleep</code>函数在<code>devices/timer.c</code>。系统现在是使用busy wait实现的，即线程不停地循环，直到时间片耗尽。更改<code>timer_sleep</code>的实现方式。</span></strong></span></p>
<p><span style="font-size: 18px; color: #ff0000;"><strong><span style="font-size: 16px; color: #000000;">我们先来看一下devices目录下timer.c中的timer_sleep实现：</span></strong></span></p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Sleeps for approximately TICKS timer ticks.  Interrupts must
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   be turned on. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 4</span> <span style="color: #000000;">timer_sleep (int64_t ticks)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>   int64_t start =<span style="color: #000000;"> timer_ticks ();
</span><span style="color: #008080;"> 7</span>   ASSERT (intr_get_level () ==<span style="color: #000000;"> INTR_ON);
</span><span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">while</span> (timer_elapsed (start) &lt;<span style="color: #000000;"> ticks)
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">    thread_yield();
</span><span style="color: #008080;">10</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>让我们一行一行解析：</p>
<p>第6行： 调用了timer_ticks函数， 让我们来看看这个函数做了什么。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the number of timer ticks since the OS booted. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #000000;">int64_t
</span><span style="color: #008080;">3</span> timer_ticks (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">6</span>   int64_t t =<span style="color: #000000;"> ticks;
</span><span style="color: #008080;">7</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">8</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
</span><span style="color: #008080;">9</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后我们注意到这里有个intr_level的东西通过intr_disable返回了一个东西，没关系，我们继续往下找。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Interrupts on or off? </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level 
</span><span style="color: #008080;">3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">4</span>     INTR_OFF,             <span style="color: #008000;">/*</span><span style="color: #008000;"> Interrupts disabled. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">5</span>     INTR_ON               <span style="color: #008000;">/*</span><span style="color: #008000;"> Interrupts enabled. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">6</span>   };</pre>
</div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Disables interrupts and returns the previous interrupt status. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level
</span><span style="color: #008080;"> 3</span> intr_disable (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_get_level ();
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Disable interrupts by clearing the interrupt flag.
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;">     Hardware Interrupts". </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>   asm <span style="color: #0000ff;">volatile</span> (<span style="color: #800000;">"</span><span style="color: #800000;">cli</span><span style="color: #800000;">"</span> : : : <span style="color: #800000;">"</span><span style="color: #800000;">memory</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> old_level;
</span><span style="color: #008080;">13</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里很明显，intr_level代表能否被中断，而intr_disable做了两件事情：1. 调用intr_get_level() 2. 直接执行汇编代码，调用汇编指令来保证这个线程不能被中断。</p>
<p>注意： 这个asm volatile是在C语言中内嵌了汇编语言，调用了CLI指令，<span style="color: #ff0000;">CLI指令不是command line interface, 而是clear interrupt, 作用是将标志寄存器的IF（interrupt flag）位置为0, IF=0时将不响应可屏蔽中断</span>。</p>
<p>好，让我们继续来看intr_get_level又做了什么鬼。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the current interrupt status. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level
</span><span style="color: #008080;"> 3</span> intr_get_level (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">  uint32_t flags;
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Push the flags register on the processor stack, then pop the
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;">     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
</span><span style="color: #008080;">10</span> <span style="color: #008000;">     Interrupts". </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span>   asm <span style="color: #0000ff;">volatile</span> (<span style="color: #800000;">"</span><span style="color: #800000;">pushfl; popl %0</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">=g</span><span style="color: #800000;">"</span><span style="color: #000000;"> (flags));
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   <span style="color: #0000ff;">return</span> flags &amp; FLAG_IF ?<span style="color: #000000;"> INTR_ON : INTR_OFF;
</span><span style="color: #008080;">14</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里就是intr_disable函数调用的最深的地方了!</p>
<p>这个函数一样是调用了汇编指令，把标志寄存器的东西放到处理器棧上，然后把值pop到flags（代表标志寄存器IF位）上，通过判断flags来返回当前终端状态(intr_level)。</p>
<p>&nbsp;</p>
<p>好， 到这里。 函数嵌套了这么多层， 我们整理一下逻辑：</p>
<p>1. intr_get_level返回了intr_level的值</p>
<p>2. intr_disable获取了当前的中断状态， 然后将当前中断状态改为不能被中断， 然后返回执行之前的中断状态。</p>
<p><span style="color: #ff0000;">有以上结论我们可以知道： timer_ticks第五行做了这么一件事情： 禁止当前行为被中断， 保存禁止被中断前的中断状态（用old_level储存）。</span></p>
<p>让我们再来看timer_ticks剩下的做了什么， 剩下的就是用t获取了一个全局变量ticks, 然后返回， 其中调用了set_level函数。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Enables or disables interrupts as specified by LEVEL and
</span><span style="color: #008080;">2</span> <span style="color: #008000;">   returns the previous interrupt status. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">3</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level
</span><span style="color: #008080;">4</span> intr_set_level (<span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level level) 
</span><span style="color: #008080;">5</span> <span style="color: #000000;">{
</span><span style="color: #008080;">6</span>   <span style="color: #0000ff;">return</span> level == INTR_ON ?<span style="color: #000000;"> intr_enable () : intr_disable ();
</span><span style="color: #008080;">7</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>有了之前的基础，这个函数就很容易看了， 如果之前是允许中断的（INTR_ON）则enable否则就disable.</p>
<p>而intr_enable正如你们所想，实现和之前基本一致：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Enables interrupts and returns the previous interrupt status. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level
</span><span style="color: #008080;"> 3</span> intr_enable (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_get_level ();
</span><span style="color: #008080;"> 6</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Enable interrupts by setting the interrupt flag.
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #008000;">     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
</span><span style="color: #008080;">11</span> <span style="color: #008000;">     Hardware Interrupts". </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">12</span>   asm <span style="color: #0000ff;">volatile</span> (<span style="color: #800000;">"</span><span style="color: #800000;">sti</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> old_level;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">}</span><span style="color: #008080;"><br></span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>说明一下， sti指令就是cli指令的反面，将IF位置为1。</p>
<p>然后有个ASSERT断言了intr_context函数返回结果的false。</p>
<p>再来看intr_context</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns true during processing of an external interrupt
</span><span style="color: #008080;">2</span> <span style="color: #008000;">   and false at all other times. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">3</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">4</span> intr_context (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;">5</span> <span style="color: #000000;">{
</span><span style="color: #008080;">6</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> in_external_intr;
</span><span style="color: #008080;">7</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p><span style="color: #ff0000;">这里直接返回了是否外中断的标志in_external_intr， 就是说ASSERT断言这个中断不是外中断（IO等， 也称为硬中断）而是操作系统正常线程切换流程里的内中断（也称为软中断）。</span></p>
<p><span style="color: #000000;">好的， 至此， 我们总结一下：&nbsp;</span></p>
<p>这么多分析其实分析出了pintos操作系统如何利用中断机制来确保一个原子性的操作的。</p>
<p>我们来看， 我们已经分析完了timer_ticks这个函数， &nbsp;它其实就是获取ticks的当前值返回而已， 而第5行和第7行做的其实只是确保这个过程是不能被中断的而已。</p>
<p><span style="line-height: 1.5;">那么我们来达成一个共识， 被以下两个语句包裹的内容目的是为了保证这个过程不被中断。</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">2</span> <span style="color: #000000;">...
</span><span style="color: #008080;">3</span> intr_set_level (old_level);</pre>
</div>
<p>好的， 那么ticks又是什么？ 来看ticks定义。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Number of timer ticks since OS booted. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">static</span> int64_t ticks;</pre>
</div>
<p>从pintos被启动开始， ticks就一直在计时， 代表着操作系统执行单位时间的前进计量。</p>
<p>好， 现在回过来看timer_sleep这个函数， start获取了起始时间， 然后断言必须可以被中断， 不然会一直死循环下去， 然后就是一个循环</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">while</span> (timer_elapsed (start) &lt;<span style="color: #000000;"> ticks)
</span><span style="color: #008080;">2</span>   thread_yield();</pre>
</div>
<p>注意这个ticks是函数的形参不是全局变量， 然后看一下这两个函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the number of timer ticks elapsed since THEN, which
</span><span style="color: #008080;">2</span> <span style="color: #008000;">   should be a value once returned by timer_ticks(). </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">3</span> <span style="color: #000000;">int64_t
</span><span style="color: #008080;">4</span> <span style="color: #000000;">timer_elapsed (int64_t then)
</span><span style="color: #008080;">5</span> <span style="color: #000000;">{
</span><span style="color: #008080;">6</span>   <span style="color: #0000ff;">return</span> timer_ticks () -<span style="color: #000000;"> then;
</span><span style="color: #008080;">7</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>很明显timer_elapsed返回了当前时间距离then的时间间隔， 那么这个循环<span style="color: #ff0000;">实质就是在ticks的时间内不断执行thread_yield</span>。</p>
<p>那么我们最后来看thread_yield是什么就可以了：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Yields the CPU.  The current thread is not put to sleep and
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   may be scheduled again immediately at the scheduler's whim. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 4</span> thread_yield (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">struct</span> thread *cur =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level old_level;
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>   old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">12</span>   <span style="color: #0000ff;">if</span> (cur !=<span style="color: #000000;"> idle_thread)
</span><span style="color: #008080;">13</span>     list_push_back (&amp;ready_list, &amp;cur-&gt;<span style="color: #000000;">elem);
</span><span style="color: #008080;">14</span>   cur-&gt;status =<span style="color: #000000;"> THREAD_READY;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">  schedule ();
</span><span style="color: #008080;">16</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">17</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;第6行thread_current函数做的事情已经可以顾名思义了， 不过具有钻研精神和强迫症的你还是要确定它的具体实现：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the running thread.
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   This is running_thread() plus a couple of sanity checks.
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   See the big comment at the top of thread.h for details. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">struct</span> thread *
<span style="color: #008080;"> 5</span> thread_current (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">struct</span> thread *t =<span style="color: #000000;"> running_thread ();
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure T is really a thread.
</span><span style="color: #008080;">10</span> <span style="color: #008000;">     If either of these assertions fire, then your thread may
</span><span style="color: #008080;">11</span> <span style="color: #008000;">     have overflowed its stack.  Each thread has less than 4 kB
</span><span style="color: #008080;">12</span> <span style="color: #008000;">     of stack, so a few big automatic arrays or moderate
</span><span style="color: #008080;">13</span> <span style="color: #008000;">     recursion can cause stack overflow. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">14</span> <span style="color: #000000;">  ASSERT (is_thread (t));
</span><span style="color: #008080;">15</span>   ASSERT (t-&gt;status ==<span style="color: #000000;"> THREAD_RUNNING);
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
</span><span style="color: #008080;">18</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the running thread. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">struct</span> thread *
<span style="color: #008080;"> 3</span> running_thread (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   uint32_t *<span style="color: #000000;">esp;
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Copy the CPU's stack pointer into `esp', and then round that
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">     down to the start of a page.  Because `struct thread' is
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;">     always at the beginning of a page and the stack pointer is
</span><span style="color: #008080;">10</span> <span style="color: #008000;">     somewhere in the middle, this locates the curent thread. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span>   asm (<span style="color: #800000;">"</span><span style="color: #800000;">mov %%esp, %0</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">=g</span><span style="color: #800000;">"</span><span style="color: #000000;"> (esp));
</span><span style="color: #008080;">12</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> pg_round_down (esp);
</span><span style="color: #008080;">13</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns true if T appears to point to a valid thread. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">3</span> is_thread (<span style="color: #0000ff;">struct</span> thread *<span style="color: #000000;">t)
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">return</span> t != NULL &amp;&amp; t-&gt;magic ==<span style="color: #000000;"> THREAD_MAGIC;
</span><span style="color: #008080;">6</span> }</pre>
</div>
<p>先来看thread_current调用的running_thread, 把CPU棧的指针复制到esp中， 然后调用pg_round_down</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Round down to nearest page boundary. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">static</span> inline <span style="color: #0000ff;">void</span> *pg_round_down (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span> *<span style="color: #000000;">va) {
</span><span style="color: #008080;">3</span>   <span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">void</span> *) ((uintptr_t) va &amp; ~<span style="color: #000000;">PGMASK);
</span><span style="color: #008080;">4</span> }</pre>
</div>
<p>&nbsp;好，这里又涉及到这个操作系统是怎么设计页面的了：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Page offset (bits 0:12). </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">#define</span> PGSHIFT 0                          /* Index of first offset bit. */
<span style="color: #008080;">3</span> <span style="color: #0000ff;">#define</span> PGBITS  12                         /* Number of offset bits. */
<span style="color: #008080;">4</span> <span style="color: #0000ff;">#define</span> PGSIZE  (1 &lt;&lt; PGBITS)              /* Bytes in a page. */
<span style="color: #008080;">5</span> <span style="color: #0000ff;">#define</span> PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */</pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Functions and macros for working with virtual addresses.
</span><span style="color: #008080;">2</span> 
<span style="color: #008080;">3</span> <span style="color: #008000;">   See pte.h for functions and macros specifically for x86
</span><span style="color: #008080;">4</span> <span style="color: #008000;">   hardware page tables. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">5</span> 
<span style="color: #008080;">6</span> <span style="color: #0000ff;">#define</span> BITMASK(SHIFT, CNT) (((1ul &lt;&lt; (CNT)) - 1) &lt;&lt; (SHIFT))</pre>
</div>
<p>一个页面12位， PGMASK调用BITMASK其实就是一个页面全部位都是1的这么个MASK， 注意1ul的意思是unsigned long的1。</p>
<p>然后来看pg_round_down， 对PGMASK取反的结果就是一个页面大小全部为0的这么个数， 然后和传过来的指针做与操作的结果就是清0指针的靠右12位。</p>
<p>这里有什么效果呢？ 我们知道一个页面12位， 而struct thread是在一个页面的最开始的， 所以对任何一个页面的指针做<span style="color: #ff0000;">pg_round_down的结果就是返回到这个页面最开始线程结构体的位置</span>。</p>
<p>好， 我们现在分析出了pg_round_down其实就是返回了这个页面线程的最开始指针， 那么running_thread的结果返回当前线程起始指针。</p>
<p>再来看thread_current里最后的两个断言， 一个断言t指针是一个线程， 一个断言这个线程处于THREAD_RUNNING状态。</p>
<p>然后is_thread用的t-&gt;magic其实是用于检测时候有栈溢出的这么个元素。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Owned by thread.c. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> unsigned magic;                     <span style="color: #008000;">/*</span><span style="color: #008000;"> Detects stack overflow. </span><span style="color: #008000;">*/</span></pre>
</div>
<p>好， 现在thread_current分析完了， 这个就是返回当前线程起始指针位置。</p>
<p>我们继续看thread_yield， 然后剩下的很多东西其实我们已经分析过了， 在分析的过程其实是对这个操作系统工作过程的剖析， 很多地方都是相通的。</p>
<p>第9断言这是个软中断， 第11和16包裹起来的就是我们之前分析的线程机制保证的一个原子性操作。</p>
<p>然后我们来看12-15做了什么：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (cur !=<span style="color: #000000;"> idle_thread)
</span><span style="color: #008080;">2</span>   list_push_back (&amp;ready_list, &amp;cur-&gt;<span style="color: #000000;">elem);
</span><span style="color: #008080;">3</span> cur-&gt;status =<span style="color: #000000;"> THREAD_READY;
</span><span style="color: #008080;">4</span> schedule ();</pre>
</div>
<p>&nbsp;如何当前线程不是空闲的线程就调用list_push_back把当前线程的元素扔到就绪队列里面， 并把线程改成THREAD_READY状态。</p>
<p>关于队列list的相关操作mission2会涉及到， 这里先不作解释， 顾名思义即可。</p>
<p>然后再调用schedule:</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Schedules a new process.  At entry, interrupts must be off and
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   the running process's state must have been changed from
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   running to some other state.  This function finds another
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">   thread to run and switches to it.
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #008000;">   It's not safe to call printf() until thread_schedule_tail()
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">   has completed. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 8</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 9</span> schedule (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;">10</span> <span style="color: #000000;">{
</span><span style="color: #008080;">11</span>   <span style="color: #0000ff;">struct</span> thread *cur =<span style="color: #000000;"> running_thread ();
</span><span style="color: #008080;">12</span>   <span style="color: #0000ff;">struct</span> thread *next =<span style="color: #000000;"> next_thread_to_run ();
</span><span style="color: #008080;">13</span>   <span style="color: #0000ff;">struct</span> thread *prev =<span style="color: #000000;"> NULL;
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>   ASSERT (intr_get_level () ==<span style="color: #000000;"> INTR_OFF);
</span><span style="color: #008080;">16</span>   ASSERT (cur-&gt;status !=<span style="color: #000000;"> THREAD_RUNNING);
</span><span style="color: #008080;">17</span> <span style="color: #000000;">  ASSERT (is_thread (next));
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>   <span style="color: #0000ff;">if</span> (cur !=<span style="color: #000000;"> next)
</span><span style="color: #008080;">20</span>     prev =<span style="color: #000000;"> switch_threads (cur, next);
</span><span style="color: #008080;">21</span> <span style="color: #000000;">  thread_schedule_tail (prev);
</span><span style="color: #008080;">22</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>首先获取当前线程cur和调用next_thread_to_run获取下一个要run的线程：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Chooses and returns the next thread to be scheduled.  Should
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   return a thread from the run queue, unless the run queue is
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   empty.  (If the running thread can continue running, then it
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">   will be in the run queue.)  If the run queue is empty, return
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">   idle_thread. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">struct</span> thread *
<span style="color: #008080;"> 7</span> next_thread_to_run (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">if</span> (list_empty (&amp;<span style="color: #000000;">ready_list))
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> idle_thread;
</span><span style="color: #008080;">11</span>   <span style="color: #0000ff;">else</span>
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">return</span> list_entry (list_pop_front (&amp;ready_list), <span style="color: #0000ff;">struct</span><span style="color: #000000;"> thread, elem);
</span><span style="color: #008080;">13</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>如果就绪队列空闲直接返回一个空闲线程指针， 否则拿就绪队列第一个线程出来返回。</p>
<p>然后3个断言之前讲过就不多说了， 确保不能被中断， 当前线程是RUNNING_THREAD等。</p>
<p>如果当前线程和下一个要跑的线程不是同一个的话调用switch_threads返回给prev。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Switches from CUR, which must be the running thread, to NEXT,
</span><span style="color: #008080;">2</span> <span style="color: #008000;">   which must also be running switch_threads(), returning CUR in
</span><span style="color: #008080;">3</span> <span style="color: #008000;">   NEXT's context. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">4</span> <span style="color: #0000ff;">struct</span> thread *switch_threads (<span style="color: #0000ff;">struct</span> thread *cur, <span style="color: #0000ff;">struct</span> thread *next);</pre>
</div>
<p>注意， 这个函数实现是用汇编语言实现的在threads/switch.S里：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> #### struct thread *switch_threads (struct thread *cur, struct thread *next)<span style="color: #008000;">;
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">####
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">#### Switches from CUR, which must be the running thread, to NEXT,
</span><span style="color: #008080;"> 4</span> #### which must also be running switch_threads(), returning CUR <span style="color: #0000ff;">in</span>
<span style="color: #008080;"> 5</span> #### NEXT<span style="color: #800000;">'</span><span style="color: #800000;">s context.
</span><span style="color: #008080;"> 6</span> <span style="color: #800000;">####
</span><span style="color: #008080;"> 7</span> <span style="color: #800000;">#### This function works by assuming that the thread we</span><span style="color: #800000;">'</span><span style="color: #000000;">re switching
</span><span style="color: #008080;"> 8</span> #### <span style="color: #0000ff;">into</span><span style="color: #000000;"> is also running switch_threads().  Thus, all it has to do is
</span><span style="color: #008080;"> 9</span> #### preserve a few registers on the stack, then switch stacks <span style="color: #0000ff;">and</span>
<span style="color: #008080;">10</span> <span style="color: #000000;">#### restore the registers.  As part of switching stacks we record the
</span><span style="color: #008080;">11</span> #### current stack pointer <span style="color: #0000ff;">in</span> CUR<span style="color: #800000;">'</span><span style="color: #800000;">s thread structure.
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #800000;">.globl switch_threads
</span><span style="color: #008080;">14</span> <span style="color: #800000;">.func switch_threads
</span><span style="color: #008080;">15</span> <span style="color: #800000;">switch_threads:
</span><span style="color: #008080;">16</span> <span style="color: #800000;">    # Save caller</span><span style="color: #800000;">'</span><span style="color: #000000;">s register state.
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    #
</span><span style="color: #008080;">18</span> <span style="color: #000000;">    # Note that the SVR4 ABI allows us to destroy %eax, %ecx, %edx,
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    # but requires us to preserve %ebx, %ebp, %esi, %edi.  See
</span><span style="color: #008080;">20</span>     # [SysV-ABI-<span style="color: #800080;">386</span>] pages <span style="color: #800080;">3</span>-<span style="color: #800080;">11</span> <span style="color: #0000ff;">and</span> <span style="color: #800080;">3</span>-<span style="color: #800080;">12</span><span style="color: #000000;"> for details.
</span><span style="color: #008080;">21</span> <span style="color: #000000;">    #
</span><span style="color: #008080;">22</span> <span style="color: #000000;">    # This stack frame must match the one set up by thread_create()
</span><span style="color: #008080;">23</span>     # <span style="color: #0000ff;">in</span><span style="color: #000000;"> size.
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    pushl %ebx
</span><span style="color: #008080;">25</span> <span style="color: #000000;">    pushl %ebp
</span><span style="color: #008080;">26</span> <span style="color: #000000;">    pushl %esi
</span><span style="color: #008080;">27</span> <span style="color: #000000;">    pushl %edi
</span><span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span> <span style="color: #000000;">    # Get offsetof (struct thread, stack).
</span><span style="color: #008080;">30</span> <span style="color: #000000;">.globl thread_stack_ofs
</span><span style="color: #008080;">31</span>     <span style="color: #0000ff;">mov</span><span style="color: #000000;"> thread_stack_ofs, %edx
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span>     # Save current stack pointer to old thread<span style="color: #800000;">'</span><span style="color: #800000;">s stack, if any.
</span><span style="color: #008080;">34</span> <span style="color: #800000;">    movl SWITCH_CUR(%esp), %eax
</span><span style="color: #008080;">35</span> <span style="color: #800000;">    movl %esp, (%eax,%edx,1)
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span> <span style="color: #800000;">    # Restore stack pointer from new thread</span><span style="color: #800000;">'</span><span style="color: #000000;">s stack.
</span><span style="color: #008080;">38</span> <span style="color: #000000;">    movl SWITCH_NEXT(%esp), %ecx
</span><span style="color: #008080;">39</span>     movl (%ecx,%edx,<span style="color: #800080;">1</span><span style="color: #000000;">), %esp
</span><span style="color: #008080;">40</span> 
<span style="color: #008080;">41</span>     # Restore caller<span style="color: #800000;">'</span><span style="color: #800000;">s register state.
</span><span style="color: #008080;">42</span> <span style="color: #800000;">    popl %edi
</span><span style="color: #008080;">43</span> <span style="color: #800000;">    popl %esi
</span><span style="color: #008080;">44</span> <span style="color: #800000;">    popl %ebp
</span><span style="color: #008080;">45</span> <span style="color: #800000;">    popl %ebx
</span><span style="color: #008080;">46</span> <span style="color: #800000;">        ret
</span><span style="color: #008080;">47</span> <span style="color: #800000;">.endfunc</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;分析一下这个汇编代码： 先4个寄存器压栈保存寄存器状态（保护作用）， 这4个寄存器是switch_threads_frame的成员：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> switch_thread()'s stack frame. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> switch_threads_frame 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 4</span>     uint32_t edi;               <span style="color: #008000;">/*</span><span style="color: #008000;">  0: Saved %edi. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 5</span>     uint32_t esi;               <span style="color: #008000;">/*</span><span style="color: #008000;">  4: Saved %esi. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 6</span>     uint32_t ebp;               <span style="color: #008000;">/*</span><span style="color: #008000;">  8: Saved %ebp. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>     uint32_t ebx;               <span style="color: #008000;">/*</span><span style="color: #008000;"> 12: Saved %ebx. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">void</span> (*eip) (<span style="color: #0000ff;">void</span>);         <span style="color: #008000;">/*</span><span style="color: #008000;"> 16: Return address. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">struct</span> thread *cur;         <span style="color: #008000;">/*</span><span style="color: #008000;"> 20: switch_threads()'s CUR argument. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">struct</span> thread *next;        <span style="color: #008000;">/*</span><span style="color: #008000;"> 24: switch_threads()'s NEXT argument. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span>   };</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后全局变量thread_stack_ofs记录线程和棧之间的间隙， 我们都知道线程切换有个保存现场的过程，</p>
<p>来看34,35行， 先把当前的线程指针放到eax中， 并把线程指针保存在相对基地址偏移量为edx的地址中。</p>
<p>38,39： 切换到下一个线程的线程棧指针， 保存在ecx中， 再把这个线程相对基地址偏移量edx地址（上一次保存现场的时候存放的）放到esp当中继续执行。</p>
<p>这里ecx, eax起容器的作用， edx指向当前现场保存的地址偏移量。</p>
<p>简单来说就是<span style="color: #ff0000;">保存当前线程状态， 恢复新线程之前保存的线程状态。</span></p>
<p>然后再把4个寄存器拿出来， 这个是硬件设计要求的， 必须保护switch_threads_frame里面的寄存器才可以destroy掉eax, edx, ecx。</p>
<p>然后注意到现在eax(函数返回值是eax)就是被切换的线程棧指针。</p>
<p>我们由此得到一个结论， <span style="color: #ff0000;">schedule先把当前线程丢到就绪队列，然后把线程切换如果下一个线程和当前线程不一样的话</span>。</p>
<p>然后再看shedule最后一行的函数thread_schedule_tail做了什么鬼， 这里参数prev是NULL或者在下一个线程的上下文中的当前线程指针。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Completes a thread switch by activating the new thread's page
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   tables, and, if the previous thread is dying, destroying it.
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #008000;">   At this function's invocation, we just switched from thread
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">   PREV, the new thread is already running, and interrupts are
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">   still disabled.  This function is normally invoked by
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">   thread_schedule() as its final action before returning, but
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">   the first time a thread is scheduled it is called by
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;">   switch_entry() (see switch.S).
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> <span style="color: #008000;">   It's not safe to call printf() until the thread switch is
</span><span style="color: #008080;">12</span> <span style="color: #008000;">   complete.  In practice that means that printf()s should be
</span><span style="color: #008080;">13</span> <span style="color: #008000;">   added at the end of the function.
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> <span style="color: #008000;">   After this function and its caller returns, the thread switch
</span><span style="color: #008080;">16</span> <span style="color: #008000;">   is complete. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">17</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">18</span> thread_schedule_tail (<span style="color: #0000ff;">struct</span> thread *<span style="color: #000000;">prev)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">{
</span><span style="color: #008080;">20</span>   <span style="color: #0000ff;">struct</span> thread *cur =<span style="color: #000000;"> running_thread ();
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span>   ASSERT (intr_get_level () ==<span style="color: #000000;"> INTR_OFF);
</span><span style="color: #008080;">23</span> 
<span style="color: #008080;">24</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Mark us as running. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">25</span>   cur-&gt;status =<span style="color: #000000;"> THREAD_RUNNING;
</span><span style="color: #008080;">26</span> 
<span style="color: #008080;">27</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Start new time slice. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">28</span>   thread_ticks = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">29</span> 
<span style="color: #008080;">30</span> <span style="color: #000000;">#ifdef USERPROG
</span><span style="color: #008080;">31</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Activate the new address space. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">32</span> <span style="color: #000000;">  process_activate ();
</span><span style="color: #008080;">33</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">34</span> 
<span style="color: #008080;">35</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> If the thread we switched from is dying, destroy its struct
</span><span style="color: #008080;">36</span> <span style="color: #008000;">     thread.  This must happen late so that thread_exit() doesn't
</span><span style="color: #008080;">37</span> <span style="color: #008000;">     pull out the rug under itself.  (We don't free
</span><span style="color: #008080;">38</span> <span style="color: #008000;">     initial_thread because its memory was not obtained via
</span><span style="color: #008080;">39</span> <span style="color: #008000;">     palloc().) </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">40</span>   <span style="color: #0000ff;">if</span> (prev != NULL &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev !=<span style="color: #000000;"> initial_thread)
</span><span style="color: #008080;">41</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">42</span>       ASSERT (prev !=<span style="color: #000000;"> cur);
</span><span style="color: #008080;">43</span> <span style="color: #000000;">      palloc_free_page (prev);
</span><span style="color: #008080;">44</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">45</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>先是获得当前线程cur, 注意此时是已经切换过的线程了（或者还是之前run的线程， 因为ready队列为空）。</p>
<p>然后把线程状态改成THREAD_RUNNING， 然后thread_ticks清零开始新的线程切换时间片。</p>
<p>然后调用process_activate触发新的地址空间。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Sets up the CPU for running user code in the current
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   thread.
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   This function is called on every context switch. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 5</span> process_activate (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">struct</span> thread *t =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Activate thread's page tables. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>   pagedir_activate (t-&gt;<span style="color: #000000;">pagedir);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Set thread's kernel stack for use in processing
</span><span style="color: #008080;">13</span> <span style="color: #008000;">     interrupts. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">14</span> <span style="color: #000000;">  tss_update ();
</span><span style="color: #008080;">15</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里先是拿到当前线程， 调用pagedir_activate:</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Loads page directory PD into the CPU's page directory base
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   register. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 4</span> pagedir_activate (uint32_t *<span style="color: #000000;">pd) 
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">if</span> (pd ==<span style="color: #000000;"> NULL)
</span><span style="color: #008080;"> 7</span>     pd =<span style="color: #000000;"> init_page_dir;
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Store the physical address of the page directory into CR3
</span><span style="color: #008080;">10</span> <span style="color: #008000;">     aka PDBR (page directory base register).  This activates our
</span><span style="color: #008080;">11</span> <span style="color: #008000;">     new page tables immediately.  See [IA32-v2a] "MOV--Move
</span><span style="color: #008080;">12</span> <span style="color: #008000;">     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
</span><span style="color: #008080;">13</span> <span style="color: #008000;">     Address of the Page Directory". </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">14</span>   asm <span style="color: #0000ff;">volatile</span> (<span style="color: #800000;">"</span><span style="color: #800000;">movl %0, %%cr3</span><span style="color: #800000;">"</span> : : <span style="color: #800000;">"</span><span style="color: #800000;">r</span><span style="color: #800000;">"</span> (vtop (pd)) : <span style="color: #800000;">"</span><span style="color: #800000;">memory</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这个汇编指令将当前线程的页目录指针存储到CR3（页目录表物理内存基地址寄存器）中，也就是说这个函数更新了现在的页目录表。</p>
<p>最后来看tss_update：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Sets the ring 0 stack pointer in the TSS to point to the end
</span><span style="color: #008080;">2</span> <span style="color: #008000;">   of the thread stack. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">3</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">4</span> tss_update (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;">5</span> <span style="color: #000000;">{
</span><span style="color: #008080;">6</span>   ASSERT (tss !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">7</span>   tss-&gt;esp0 = (uint8_t *) thread_current () +<span style="color: #000000;"> PGSIZE;
</span><span style="color: #008080;">8</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>首先要弄清楚tss是什么， tss是task state segment， 叫任务状态段，&nbsp;任务（进程）切换时的任务现场信息。</p>
<p>这里其实是把TSS的一个棧指针指向了当前线程棧的尾部， 也就是更新了任务现场的信息和状态。</p>
<p>好， 到现在process_activate分析完了， 总结一下： <span style="color: #ff0000;">其实就是做了2件事情： 1.更新页目录表 2.更新任务现场信息（TSS）</span></p>
<p>我们现在继续来看thread_schedule_tail， 最后是这4行：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> If the thread we switched from is dying, destroy its struct
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">     thread.  This must happen late so that thread_exit() doesn't
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">     pull out the rug under itself.  (We don't free
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">     initial_thread because its memory was not obtained via
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">     palloc().) </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">if</span> (prev != NULL &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev !=<span style="color: #000000;"> initial_thread)
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 8</span>       ASSERT (prev !=<span style="color: #000000;"> cur);
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">      palloc_free_page (prev);
</span><span style="color: #008080;">10</span>     }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里是如果我们切换的线程状态是THREAD_DYING（代表欲要销毁的线程）的话， 调用palloc_free_page：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Frees the page at PAGE. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">3</span> palloc_free_page (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">page) 
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   palloc_free_multiple (page, <span style="color: #800080;">1</span><span style="color: #000000;">);
</span><span style="color: #008080;">6</span> }</pre>
</div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Frees the PAGE_CNT pages starting at PAGES. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> palloc_free_multiple (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">pages, size_t page_cnt) 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">struct</span> pool *<span style="color: #000000;">pool;
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  size_t page_idx;
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   ASSERT (pg_ofs (pages) == <span style="color: #800080;">0</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">if</span> (pages == NULL || page_cnt == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   <span style="color: #0000ff;">if</span> (page_from_pool (&amp;<span style="color: #000000;">kernel_pool, pages))
</span><span style="color: #008080;">13</span>     pool = &amp;<span style="color: #000000;">kernel_pool;
</span><span style="color: #008080;">14</span>   <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (page_from_pool (&amp;<span style="color: #000000;">user_pool, pages))
</span><span style="color: #008080;">15</span>     pool = &amp;<span style="color: #000000;">user_pool;
</span><span style="color: #008080;">16</span>   <span style="color: #0000ff;">else</span>
<span style="color: #008080;">17</span> <span style="color: #000000;">    NOT_REACHED ();
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>   page_idx = pg_no (pages) - pg_no (pool-&gt;<span style="color: #0000ff;">base</span><span style="color: #000000;">);
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span> <span style="color: #000000;">#ifndef NDEBUG
</span><span style="color: #008080;">22</span>   memset (pages, <span style="color: #800080;">0xcc</span>, PGSIZE *<span style="color: #000000;"> page_cnt);
</span><span style="color: #008080;">23</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">24</span> 
<span style="color: #008080;">25</span>   ASSERT (bitmap_all (pool-&gt;<span style="color: #000000;">used_map, page_idx, page_cnt));
</span><span style="color: #008080;">26</span>   bitmap_set_multiple (pool-&gt;used_map, page_idx, page_cnt, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
</span><span style="color: #008080;">27</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里创建了一个pool的结构体：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> A memory pool. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> pool
</span><span style="color: #008080;">3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">4</span>     <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> <span style="color: #0000ff;">lock</span>;                   <span style="color: #008000;">/*</span><span style="color: #008000;"> Mutual exclusion. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">5</span>     <span style="color: #0000ff;">struct</span> bitmap *used_map;            <span style="color: #008000;">/*</span><span style="color: #008000;"> Bitmap of free pages. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">6</span>     uint8_t *<span style="color: #0000ff;">base</span>;                      <span style="color: #008000;">/*</span><span style="color: #008000;"> Base of pool. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">7</span>   };</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>首先palloc实现的是一个页分配器， 这里pool的角色就是记忆分配的内容。 这里结构体用位图记录空的页， 关键是这里又有一个操作系统很重要的知识概念出现了，就是lock：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Lock. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> 
<span style="color: #008080;">3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">4</span>     <span style="color: #0000ff;">struct</span> thread *holder;      <span style="color: #008000;">/*</span><span style="color: #008000;"> Thread holding lock (for debugging). </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">5</span>     <span style="color: #0000ff;">struct</span> semaphore semaphore; <span style="color: #008000;">/*</span><span style="color: #008000;"> Binary semaphore controlling access. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">6</span>   };</pre>
</div>
<p>然后锁其实是由二值信号量实现的：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> A counting semaphore. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> semaphore 
</span><span style="color: #008080;">3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">4</span>     unsigned value;             <span style="color: #008000;">/*</span><span style="color: #008000;"> Current value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">5</span>     <span style="color: #0000ff;">struct</span> list waiters;        <span style="color: #008000;">/*</span><span style="color: #008000;"> List of waiting threads. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">6</span>   };</pre>
</div>
<p>具体信号量方法实现在threads/synch.c中， 这里不作更多讲解了， 毕竟函数分析还没涉及到这里。</p>
<p>继续看palloc_free_multiple， 第8行其实就是截取后12位， 即获得当前页偏差量， 断言为0就是说页指针应该指向线程结构体</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Offset within a page. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">static</span> inline unsigned pg_ofs (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span> *<span style="color: #000000;">va) {
</span><span style="color: #008080;">3</span>   <span style="color: #0000ff;">return</span> (uintptr_t) va &amp;<span style="color: #000000;"> PGMASK;
</span><span style="color: #008080;">4</span> }</pre>
</div>
<p>然后分析12-17行， 这里要弄清楚一点是系统memory分成2个池， 一个是kernel pool, 一个是user pool，&nbsp;user pool是提供给用户页的， 别的都是kernel pool。</p>
<p>然后看下这里调用的page_from_pool函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns true if PAGE was allocated from POOL,
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   false otherwise. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 4</span> page_from_pool (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> pool *pool, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">page) 
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>   size_t page_no =<span style="color: #000000;"> pg_no (page);
</span><span style="color: #008080;"> 7</span>   size_t start_page = pg_no (pool-&gt;<span style="color: #0000ff;">base</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>   size_t end_page = start_page + bitmap_size (pool-&gt;<span style="color: #000000;">used_map);
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>   <span style="color: #0000ff;">return</span> page_no &gt;= start_page &amp;&amp; page_no &lt;<span style="color: #000000;"> end_page;
</span><span style="color: #008080;">11</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>pg_no是获取虚拟页数的， 方法其实就是直接指针右移12位就行了：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Virtual page number. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">static</span> inline uintptr_t pg_no (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span> *<span style="color: #000000;">va) {
</span><span style="color: #008080;">3</span>   <span style="color: #0000ff;">return</span> (uintptr_t) va &gt;&gt;<span style="color: #000000;"> PGBITS;
</span><span style="color: #008080;">4</span> }</pre>
</div>
<p>然后这里获取当前池中的的起始页和结束页位置， 然后判断页面时候在这个池的Number范围之类来判断时候属于某个池。</p>
<p>再看NOT_REACHED函数,这个函数博主找了半天， 最后用全文件搜索才找着在哪，在lib/debug.h中：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> This is outside the header guard so that debug.h may be
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   included multiple times with different settings of NDEBUG. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">#undef</span> ASSERT
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">#undef</span> NOT_REACHED
<span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #000000;">#ifndef NDEBUG
</span><span style="color: #008080;"> 7</span> <span style="color: #0000ff;">#define</span> ASSERT(CONDITION)                                       \
<span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">if</span> (CONDITION) { } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {                               \
</span><span style="color: #008080;"> 9</span>                 PANIC (<span style="color: #800000;">"</span><span style="color: #800000;">assertion `%s' failed.</span><span style="color: #800000;">"</span><span style="color: #000000;">, #CONDITION);   \
</span><span style="color: #008080;">10</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">#define</span> NOT_REACHED() PANIC ("executed an unreachable statement");
<span style="color: #008080;">12</span> <span style="color: #0000ff;">#else</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">#define</span> ASSERT(CONDITION) ((void) 0)
<span style="color: #008080;">14</span> <span style="color: #0000ff;">#define</span> NOT_REACHED() for (;;)
<span style="color: #008080;">15</span> <span style="color: #0000ff;">#endif</span> /* lib/debug.h */</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> GCC lets us add "attributes" to functions, function
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   parameters, etc. to indicate their properties.
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   See the GCC manual for details. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">#define</span> UNUSED __attribute__ ((unused))
<span style="color: #008080;"> 5</span> <span style="color: #0000ff;">#define</span> NO_RETURN __attribute__ ((noreturn))
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">#define</span> NO_INLINE __attribute__ ((noinline))
<span style="color: #008080;"> 7</span> <span style="color: #0000ff;">#define</span> PRINTF_FORMAT(FMT, FIRST) __attribute__ ((format (printf, FMT, FIRST)))
<span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Halts the OS, printing the source file name, line number, and
</span><span style="color: #008080;">10</span> <span style="color: #008000;">   function name, plus a user-specific message. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span> <span style="color: #0000ff;">#define</span> PANIC(...) debug_panic (__FILE__, __LINE__, __func__, __VA_ARGS__)
<span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #0000ff;">void</span> debug_panic (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *file, <span style="color: #0000ff;">int</span> line, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">function,
</span><span style="color: #008080;">14</span>                   <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *message, ...) PRINTF_FORMAT (<span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>) NO_RETURN;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;这里根据NDEBUG状态分两种define， 一个是ASSERT空函数， NOT_REACHED执行死循环， 一个是如果ASSERT参数CONDITION为false的话就调用PANIC输出文件，行数，函数名和用户信息， NOT_REACHED也会输出信息。</p>
<p>有些童鞋在跑测试的时候会出现卡在一个地方不动的状态， 其实不是因为你电脑的问题， 而是当一些错误触发NOT_REACHED之类的问题的时候， 因为非debug环境就一直执行死循环了， 反映出来的行为就是命令行卡住不动没有输出。</p>
<p>注意这里的语法类似__attribute__和((format(printf, m , n)))是面向gcc编译器处理的写法， 这里做的事情其实是<span style="color: #ff0000;">参数声明和调用匹配性检查</span>。</p>
<p>&nbsp;好， 继续来看palloc_free_multiple， 用page_idx保存了计算出来了页id， 清空了页指针， 然后还剩下最后两行：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   ASSERT (bitmap_all (pool-&gt;<span style="color: #000000;">used_map, page_idx, page_cnt));
</span><span style="color: #008080;">2</span>   bitmap_set_multiple (pool-&gt;used_map, page_idx, page_cnt, <span style="color: #0000ff;">false</span>);</pre>
</div>
<p>第一个断言：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns true if every bit in B between START and START + CNT,
</span><span style="color: #008080;">2</span> <span style="color: #008000;">   exclusive, is set to true, and false otherwise. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">3</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">4</span> bitmap_all (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> bitmap *<span style="color: #000000;">b, size_t start, size_t cnt) 
</span><span style="color: #008080;">5</span> <span style="color: #000000;">{
</span><span style="color: #008080;">6</span>   <span style="color: #0000ff;">return</span> !bitmap_contains (b, start, cnt, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
</span><span style="color: #008080;">7</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns true if any bits in B between START and START + CNT,
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   exclusive, are set to VALUE, and false otherwise. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 4</span> bitmap_contains (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> bitmap *b, size_t start, size_t cnt, <span style="color: #0000ff;">bool</span><span style="color: #000000;"> value) 
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  size_t i;
</span><span style="color: #008080;"> 7</span>   
<span style="color: #008080;"> 8</span>   ASSERT (b !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;"> 9</span>   ASSERT (start &lt;= b-&gt;<span style="color: #000000;">bit_cnt);
</span><span style="color: #008080;">10</span>   ASSERT (start + cnt &lt;= b-&gt;<span style="color: #000000;">bit_cnt);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; cnt; i++<span style="color: #000000;">)
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">if</span> (bitmap_test (b, start + i) ==<span style="color: #000000;"> value)
</span><span style="color: #008080;">14</span>       <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
</span><span style="color: #008080;">15</span>   <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">16</span> }&nbsp;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;bitmap_contains首先做断言对参数正确性确认， 然后如果所有位处于start到start+cnt都是value的话， 别的都是~value的话， 返回true， 从我们的函数调用来看就是断言位图全是0。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the value of the bit numbered IDX in B. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">3</span> bitmap_test (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> bitmap *<span style="color: #000000;">b, size_t idx) 
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   ASSERT (b !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">6</span>   ASSERT (idx &lt; b-&gt;<span style="color: #000000;">bit_cnt);
</span><span style="color: #008080;">7</span>   <span style="color: #0000ff;">return</span> (b-&gt;bits[elem_idx (idx)] &amp; bit_mask (idx)) != <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">8</span> <span style="color: #000000;">}
</span><span style="color: #008080;">9</span> </pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the index of the element that contains the bit
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   numbered BIT_IDX. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> inline size_t
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">elem_idx (size_t bit_idx) 
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">return</span> bit_idx /<span style="color: #000000;"> ELEM_BITS;
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns an elem_type where only the bit corresponding to
</span><span style="color: #008080;">10</span> <span style="color: #008000;">   BIT_IDX is turned on. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> inline elem_type
</span><span style="color: #008080;">12</span> <span style="color: #000000;">bit_mask (size_t bit_idx) 
</span><span style="color: #008080;">13</span> <span style="color: #000000;">{
</span><span style="color: #008080;">14</span>   <span style="color: #0000ff;">return</span> (elem_type) <span style="color: #800080;">1</span> &lt;&lt; (bit_idx %<span style="color: #000000;"> ELEM_BITS);
</span><span style="color: #008080;">15</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>来看bit_test的实现， 这里直接返回某一位的具体值。</p>
<p>&nbsp;这里直接用elem_idx获取idx对应的index取出位， 然后和bit_mask做与操作， bit_mask就是返回了一个只有idx位是1其他都是0的一个数， 也就是说idx必须为1才返回true对bit_test来说， 否则false。</p>
<p>好， 至此， 对palloc_free_multiple只剩一行了：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   bitmap_set_multiple (pool-&gt;used_map, page_idx, page_cnt, <span style="color: #0000ff;">false</span>);</pre>
</div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/*</span><span style="color: #008000;"> Sets the CNT bits starting at START in B to VALUE. </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">void</span><span style="color: #000000;">
bitmap_set_multiple (</span><span style="color: #0000ff;">struct</span> bitmap *b, size_t start, size_t cnt, <span style="color: #0000ff;">bool</span><span style="color: #000000;"> value) 
{
  size_t i;
  
  ASSERT (b </span>!=<span style="color: #000000;"> NULL);
  ASSERT (start </span>&lt;= b-&gt;<span style="color: #000000;">bit_cnt);
  ASSERT (start </span>+ cnt &lt;= b-&gt;<span style="color: #000000;">bit_cnt);

  </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; cnt; i++<span style="color: #000000;">)
    bitmap_set (b, start </span>+<span style="color: #000000;"> i, value);
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里对位图所有位都做了bitmap_set设置：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Atomically sets the bit numbered IDX in B to VALUE. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> bitmap_set (<span style="color: #0000ff;">struct</span> bitmap *b, size_t idx, <span style="color: #0000ff;">bool</span><span style="color: #000000;"> value) 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   ASSERT (b !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;"> 6</span>   ASSERT (idx &lt; b-&gt;<span style="color: #000000;">bit_cnt);
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">if</span><span style="color: #000000;"> (value)
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    bitmap_mark (b, idx);
</span><span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">else</span>
<span style="color: #008080;">10</span> <span style="color: #000000;">    bitmap_reset (b, idx);
</span><span style="color: #008080;">11</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>很明显这里mark就是设为1, reset就是置为0。</p>
<p>来看一下实现：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Atomically sets the bit numbered BIT_IDX in B to true. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> bitmap_mark (<span style="color: #0000ff;">struct</span> bitmap *<span style="color: #000000;">b, size_t bit_idx) 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   size_t idx =<span style="color: #000000;"> elem_idx (bit_idx);
</span><span style="color: #008080;"> 6</span>   elem_type mask =<span style="color: #000000;"> bit_mask (bit_idx);
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This is equivalent to `b-&gt;bits[idx] |= mask' except that it
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;">     is guaranteed to be atomic on a uniprocessor machine.  See
</span><span style="color: #008080;">10</span> <span style="color: #008000;">     the description of the OR instruction in [IA32-v2b]. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span>   asm (<span style="color: #800000;">"</span><span style="color: #800000;">orl %1, %0</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">=m</span><span style="color: #800000;">"</span> (b-&gt;bits[idx]) : <span style="color: #800000;">"</span><span style="color: #800000;">r</span><span style="color: #800000;">"</span> (mask) : <span style="color: #800000;">"</span><span style="color: #800000;">cc</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Atomically sets the bit numbered BIT_IDX in B to false. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">15</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">16</span> bitmap_reset (<span style="color: #0000ff;">struct</span> bitmap *<span style="color: #000000;">b, size_t bit_idx) 
</span><span style="color: #008080;">17</span> <span style="color: #000000;">{
</span><span style="color: #008080;">18</span>   size_t idx =<span style="color: #000000;"> elem_idx (bit_idx);
</span><span style="color: #008080;">19</span>   elem_type mask =<span style="color: #000000;"> bit_mask (bit_idx);
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This is equivalent to `b-&gt;bits[idx] &amp;= ~mask' except that it
</span><span style="color: #008080;">22</span> <span style="color: #008000;">     is guaranteed to be atomic on a uniprocessor machine.  See
</span><span style="color: #008080;">23</span> <span style="color: #008000;">     the description of the AND instruction in [IA32-v2a]. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">24</span>   asm (<span style="color: #800000;">"</span><span style="color: #800000;">andl %1, %0</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">=m</span><span style="color: #800000;">"</span> (b-&gt;bits[idx]) : <span style="color: #800000;">"</span><span style="color: #800000;">r</span><span style="color: #800000;">"</span> (~mask) : <span style="color: #800000;">"</span><span style="color: #800000;">cc</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">25</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>一样， 最底层的实现依然是用汇编语言实现的， 两个汇编语言实现的就是两个逻辑： 1. b-&gt;bits[idx] |= mask 2. b-&gt;bits[idx] &amp;= ~mask， 这里mask都是只有idx位为1, 其他为0的mask。</p>
<p>好， 到现在位置palloc_free_multiple已经分析完了， 整理一下逻辑：</p>
<p>其实就是<span style="color: #ff0000;">把页的位图全部清0了， 清0代表这这个页表的所有页都是free的， 等于清空了页目录表中的所有页面</span>。</p>
<p>逻辑继续向上回溯：</p>
<p><span style="color: #ff0000;">thread_schedule_tail其实就是获取当前线程， 分配恢复之前执行的状态和现场， 如果当前线程死了就清空资源。&nbsp;</span></p>
<p><span style="color: #ff0000;">schedule其实就是拿下一个线程切换过来继续run。</span></p>
<p><span style="color: #ff0000;">thread_yield其实就是把当前线程扔到就绪队列里， 然后重新schedule， 注意这里如果ready队列为空的话当前线程会继续在cpu执行。</span></p>
<p><span style="color: #ff0000;">最后回溯到我们最顶层的函数逻辑： timer_sleep就是在ticks时间内， 如果线程处于running状态就不断把他扔到就绪队列不让他执行。</span></p>
<p>好的， 至此我们对原来的timer_sleep的实现方式有了十分清楚的理解了， 我们也很清楚的看到了它的缺点：</p>
<p><span style="color: #ff0000; font-size: 18px;">线程依然不断在cpu就绪队列和running队列之间来回， 占用了cpu资源， 这并不是我们想要的， 我们希望用一种唤醒机制来实现这个函数。&nbsp;</span></p>
<p><span style="line-height: 1.5;">&nbsp;</span></p>
<p><strong><span style="line-height: 1.5; font-size: 18pt;"><a name="timer_sleep"></a>函数重新实现：</span></strong></p>
<p>&nbsp;实现思路： 调用timer_sleep的时候直接把线程阻塞掉，然后给线程结构体加一个成员ticks_blocked来记录这个线程被sleep了多少时间， 然后利用操作系统自身的时钟中断（每个tick会执行一次）加入对线程状态的检测， 每次检测将ticks_blocked减1, 如果减到0就唤醒这个线程。</p>
<p>具体代码：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Sleeps for approximately TICKS timer ticks.  Interrupts must
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   be turned on. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 4</span> <span style="color: #000000;">timer_sleep (int64_t ticks)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">if</span> (ticks &lt;= <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">10</span>   ASSERT (intr_get_level () ==<span style="color: #000000;"> INTR_ON);
</span><span style="color: #008080;">11</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">12</span>   <span style="color: #0000ff;">struct</span> thread *current_thread =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;">13</span>   current_thread-&gt;ticks_blocked =<span style="color: #000000;"> ticks;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">  thread_block ();
</span><span style="color: #008080;">15</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">16</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>注意这里调用的thread_block：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Puts the current thread to sleep.  It will not be scheduled
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   again until awoken by thread_unblock().
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #008000;">   This function must be called with interrupts turned off.  It
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">   is usually a better idea to use one of the synchronization
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">   primitives in synch.h. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 8</span> thread_block (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">{
</span><span style="color: #008080;">10</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;">11</span>   ASSERT (intr_get_level () ==<span style="color: #000000;"> INTR_OFF);
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   thread_current ()-&gt;status =<span style="color: #000000;"> THREAD_BLOCKED;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">  schedule ();
</span><span style="color: #008080;">15</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>线程的各种原理之前分析都已经剖析过了， 不作过多解释。</p>
<p>给线程的结构体加上我们的ticks_blocked成员：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> Record the time the thread has been blocked. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span>     int64_t ticks_blocked;</pre>
</div>
<p>然后在线程被创建的时候初始化ticks_blocked为0， 加在thread_create函数内：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   t-&gt;ticks_blocked = <span style="color: #800080;">0</span>;</pre>
</div>
<p>然后修改时钟中断处理函数， 加入线程sleep时间的检测， 加在timer_interrupt内：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   thread_foreach (blocked_thread_check, NULL);</pre>
</div>
<p>这里的thread_foreach就是对每个线程都执行blocked_thread_check这个函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Invoke function 'func' on all threads, passing along 'aux'.
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   This function must be called with interrupts off. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 4</span> thread_foreach (thread_action_func *func, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">struct</span> list_elem *<span style="color: #000000;">e;
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   ASSERT (intr_get_level () ==<span style="color: #000000;"> INTR_OFF);
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>   <span style="color: #0000ff;">for</span> (e = list_begin (&amp;all_list); e != list_end (&amp;<span style="color: #000000;">all_list);
</span><span style="color: #008080;">11</span>        e =<span style="color: #000000;"> list_next (e))
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">13</span>       <span style="color: #0000ff;">struct</span> thread *t = list_entry (e, <span style="color: #0000ff;">struct</span><span style="color: #000000;"> thread, allelem);
</span><span style="color: #008080;">14</span> <span style="color: #000000;">      func (t, aux);
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">16</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>aux就是传给这个函数的参数。</p>
<p>然后， 给thread添加一个方法blocked_thread_check即可：</p>
<p>thread.h中声明：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">void</span> blocked_thread_check (<span style="color: #0000ff;">struct</span> thread *t, <span style="color: #0000ff;">void</span> *aux UNUSED);</pre>
</div>
<p>thread.c：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Check the blocked thread </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> blocked_thread_check (<span style="color: #0000ff;">struct</span> thread *t, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;ticks_blocked &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 7</span>       t-&gt;ticks_blocked--<span style="color: #000000;">;
</span><span style="color: #008080;"> 8</span>       <span style="color: #0000ff;">if</span> (t-&gt;ticks_blocked == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">10</span> <span style="color: #000000;">          thread_unblock(t);
</span><span style="color: #008080;">11</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">12</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">13</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>thread_unblock就是把线程丢到就绪队列里继续跑：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Transitions a blocked thread T to the ready-to-run state.
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   This is an error if T is not blocked.  (Use thread_yield() to
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   make the running thread ready.)
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span> <span style="color: #008000;">   This function does not preempt the running thread.  This can
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">   be important: if the caller had disabled interrupts itself,
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">   it may expect that it can atomically unblock a thread and
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">   update other data. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">10</span> thread_unblock (<span style="color: #0000ff;">struct</span> thread *<span style="color: #000000;">t)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">{
</span><span style="color: #008080;">12</span>   <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level old_level;
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #000000;">  ASSERT (is_thread (t));
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>   old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">17</span>   ASSERT (t-&gt;status ==<span style="color: #000000;"> THREAD_BLOCKED);
</span><span style="color: #008080;">18</span>   list_push_back (&amp;ready_list, &amp;t-&gt;<span style="color: #000000;">elem);
</span><span style="color: #008080;">19</span>   t-&gt;status =<span style="color: #000000;"> THREAD_READY;
</span><span style="color: #008080;">20</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">21</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>好的， 这样timer_sleep函数唤醒机制就实现了。</p>
<p>然后跑测试结果会是这样的：</p>
<p>&nbsp;<img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/211459032966878.png" alt=""></p>
<p>好， 我们还需要pass掉alarm_priority我们这个实验一就算完成了，继续搞~</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>Mission2:</strong></span></p>
<p><span style="color: #ff0000; font-size: 14pt;"><strong><code>实现优先级调度（2.2.3）</code></strong></span></p>
<p>&nbsp;先来分析一下线程， 线程成员本身就有一个priority。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> thread
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 3</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> Owned by thread.c. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 4</span>     tid_t tid;                          <span style="color: #008000;">/*</span><span style="color: #008000;"> Thread identifier. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">enum</span> thread_status status;          <span style="color: #008000;">/*</span><span style="color: #008000;"> Thread state. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">16</span>];                      <span style="color: #008000;">/*</span><span style="color: #008000;"> Name (for debugging purposes). </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>     uint8_t *stack;                     <span style="color: #008000;">/*</span><span style="color: #008000;"> Saved stack pointer. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">int</span> priority;                       <span style="color: #008000;">/*</span><span style="color: #008000;"> Priority. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">struct</span> list_elem allelem;           <span style="color: #008000;">/*</span><span style="color: #008000;"> List element for all threads list. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> Shared between thread.c and synch.c. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">struct</span> list_elem elem;              <span style="color: #008000;">/*</span><span style="color: #008000;"> List element. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #000000;">#ifdef USERPROG
</span><span style="color: #008080;">15</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> Owned by userprog/process.c. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">16</span>     uint32_t *pagedir;                  <span style="color: #008000;">/*</span><span style="color: #008000;"> Page directory. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">17</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> Owned by thread.c. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">20</span>     unsigned magic;                     <span style="color: #008000;">/*</span><span style="color: #008000;"> Detects stack overflow. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> Record the time the thread has been blocked. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">23</span> <span style="color: #000000;">    int64_t ticks_blocked;
</span><span style="color: #008080;">24</span>   };</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后priority的约束：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Thread priorities. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">#define</span> PRI_MIN 0                       /* Lowest priority. */
<span style="color: #008080;">3</span> <span style="color: #0000ff;">#define</span> PRI_DEFAULT 31                  /* Default priority. */
<span style="color: #008080;">4</span> <span style="color: #0000ff;">#define</span> PRI_MAX 63                      /* Highest priority. */</pre>
</div>
<p>我们之前分析timer_sleep的时候其实已经对线程的调度有了非常深刻的剖析了，这里<span style="color: #ff0000;">实现优先级调度的核心思想就是： 维持就绪队列为一个优先级队列</span>。</p>
<p>换一种说法： 我们在插入线程到就绪队列的时候保证这个队列是一个优先级队列即可。</p>
<p>那么我们在什么时候会把一个线程丢到就绪队列中呢？</p>
<p><span style="line-height: 1.5;">1. thread_unblock</span></p>
<p><span style="line-height: 1.5;">2. init_thread</span></p>
<p><span style="line-height: 1.5;">3. thread_yield</span></p>
<p><span style="line-height: 1.5;">那么我们只要在扔的时候维持这个就绪队列是优先级队列即可。</span></p>
<p>我们来看： thread_unblock现在丢进队列里是这么干的：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   list_push_back (&amp;ready_list, &amp;t-&gt;elem);</pre>
</div>
<p>这个是直接扔到队列尾部了， 我们并不希望这么做， 于是我们只要改一下这个扔的动作就可以了，因为调度的时候下一个thread是直接取队头的。</p>
<p>那么我们先来研究一下pintos的队列是如何搞的，在/lib/kernel/：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> List element. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> list_elem 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">struct</span> list_elem *prev;     <span style="color: #008000;">/*</span><span style="color: #008000;"> Previous list element. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">struct</span> list_elem *next;     <span style="color: #008000;">/*</span><span style="color: #008000;"> Next list element. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">  };
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> List. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> list 
</span><span style="color: #008080;">10</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">struct</span> list_elem head;      <span style="color: #008000;">/*</span><span style="color: #008000;"> List head. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">struct</span> list_elem tail;      <span style="color: #008000;">/*</span><span style="color: #008000;"> List tail. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">13</span>   };</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>很常见的队列数据结构， 继续研究一下现在队列有哪些有用的函数可以帮助我们实现优先级队列：</p>
<p>然后喜大普奔地发现了一些神奇的函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Operations on lists with ordered elements. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">void</span> list_sort (<span style="color: #0000ff;">struct</span> list *<span style="color: #000000;">,
</span><span style="color: #008080;">3</span>                 list_less_func *, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux);
</span><span style="color: #008080;">4</span> <span style="color: #0000ff;">void</span> list_insert_ordered (<span style="color: #0000ff;">struct</span> list *, <span style="color: #0000ff;">struct</span> list_elem *<span style="color: #000000;">,
</span><span style="color: #008080;">5</span>                           list_less_func *, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux);
</span><span style="color: #008080;">6</span> <span style="color: #0000ff;">void</span> list_unique (<span style="color: #0000ff;">struct</span> list *, <span style="color: #0000ff;">struct</span> list *<span style="color: #000000;">duplicates,
</span><span style="color: #008080;">7</span>                   list_less_func *, <span style="color: #0000ff;">void</span> *aux);</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>list_insert_ordered不就是为我们这里的实现量身订造的么！搞起！！</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Inserts ELEM in the proper position in LIST, which must be
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   sorted according to LESS given auxiliary data AUX.
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   Runs in O(n) average case in the number of elements in LIST. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 5</span> list_insert_ordered (<span style="color: #0000ff;">struct</span> list *list, <span style="color: #0000ff;">struct</span> list_elem *<span style="color: #000000;">elem,
</span><span style="color: #008080;"> 6</span>                      list_less_func *less, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux)
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">struct</span> list_elem *<span style="color: #000000;">e;
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>   ASSERT (list !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">11</span>   ASSERT (elem !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">12</span>   ASSERT (less !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span>   <span style="color: #0000ff;">for</span> (e = list_begin (list); e != list_end (list); e =<span style="color: #000000;"> list_next (e))
</span><span style="color: #008080;">15</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (less (elem, e, aux))
</span><span style="color: #008080;">16</span>       <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">17</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> list_insert (e, elem);
</span><span style="color: #008080;">18</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>直接修改thread_unblock函数把list_push_back改成：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   list_insert_ordered (&amp;ready_list, &amp;t-&gt;elem, (list_less_func *) &amp;thread_cmp_priority, NULL);</pre>
</div>
<p>然后实现一下比较函数thread_cmp_priority：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> priority compare function. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">3</span> thread_cmp_priority (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> list_elem *a, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> list_elem *b, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED)
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">return</span> list_entry(a, <span style="color: #0000ff;">struct</span> thread, elem)-&gt;priority &gt; list_entry(b, <span style="color: #0000ff;">struct</span> thread, elem)-&gt;<span style="color: #000000;">priority;
</span><span style="color: #008080;">6</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后对thread_yield和thread_init里的list_push_back作同样的修改：</p>
<p>init_thread:</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   list_insert_ordered (&amp;all_list, &amp;t-&gt;allelem, (list_less_func *) &amp;thread_cmp_priority, NULL);</pre>
</div>
<p>thread_yield:</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>     list_insert_ordered (&amp;ready_list, &amp;cur-&gt;elem, (list_less_func *) &amp;thread_cmp_priority, NULL);</pre>
</div>
<p>做完这些工作之后， 就兴高采烈地发现alarm_priority这个测试pass了。</p>
<p>&nbsp;<img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/221012387816657.jpg" alt=""></p>
<p>&nbsp;</p>
<p>好的， 我们实现了一个优先级队列， 但是因为这个<span style="color: #ff0000;">优先级机制还会引出一系列的问题， 就是我们接下来要解决的问题</span>。</p>
<p>下面让我们来pass这两个test：</p>
<p>priority-change</p>
<p>priority-preempt</p>
<p><span style="line-height: 1.5;">我们直接TDD吧， 测试驱动开发， 来看测试做了什么：</span></p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_preempt (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 5</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure our priority is the default. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 8</span>   ASSERT (thread_get_priority () ==<span style="color: #000000;"> PRI_DEFAULT);
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">high-priority</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">1</span><span style="color: #000000;">, simple_thread_func, NULL);
</span><span style="color: #008080;">11</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">The high-priority thread should have already completed.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> 
<span style="color: #008080;">15</span> simple_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED) 
</span><span style="color: #008080;">16</span> <span style="color: #000000;">{
</span><span style="color: #008080;">17</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">18</span>   
<span style="color: #008080;">19</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">5</span>; i++<span style="color: #000000;">) 
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">21</span>       msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread %s iteration %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name (), i);
</span><span style="color: #008080;">22</span> <span style="color: #000000;">      thread_yield ();
</span><span style="color: #008080;">23</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">24</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread %s done!</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name ());
</span><span style="color: #008080;">25</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>先分析一下抢占式调度的测试， 其实就是在创建一个线程的时候， 如果线程高于当前线程就先执行创建的线程。</p>
<p>然后下面这个测试是基于抢占式调度的基础之上做的测试：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_change (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 5</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Creating a high-priority thread 2.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">thread 2</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">1</span><span style="color: #000000;">, changing_thread, NULL);
</span><span style="color: #008080;"> 9</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread 2 should have just lowered its priority.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">10</span>   thread_set_priority (PRI_DEFAULT - <span style="color: #800080;">2</span><span style="color: #000000;">);
</span><span style="color: #008080;">11</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread 2 should have just exited.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">15</span> changing_thread (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED) 
</span><span style="color: #008080;">16</span> <span style="color: #000000;">{
</span><span style="color: #008080;">17</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread 2 now lowering priority.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">18</span>   thread_set_priority (PRI_DEFAULT - <span style="color: #800080;">1</span><span style="color: #000000;">);
</span><span style="color: #008080;">19</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread 2 exiting.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">20</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>而测试希望的输出结果是这样的：</p>
<p>&nbsp;<img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/222132312035576.jpg" alt=""></p>
<p>所以我们得出一个结论就是： 测试线程(我们称为thread1)创建了一个PRI_DEFAULT+1优先级的内核线程thread2，然后由于thread2优先级高，</p>
<p>所以线程执行直接切换到thread2， thread1阻塞， 然后thread2执行的时候调用的是changing_thread， 又把自身优先级调为PRI_DEFAULT-1,</p>
<p>这个时候thread1的优先级就大于thread2了， 此时thread2阻塞于最后一个msg输出， 线程切换到thread1， 然后thread1又把自己优先级改成PRI_DEFAULT-2,</p>
<p>这个时候thread2又高于thread1了， 所以执行thread2， 然后在输出thread1的msg， 于是整个过程就有了图中的测试输出结果。</p>
<p>&nbsp;</p>
<p>分析这个测试行为我们得出的结论就是： <span style="color: #ff0000;">在设置一个线程优先级要立即重新考虑所有线程执行顺序， 重新安排执行顺序。</span></p>
<p>好， 弄清楚思路实现其实就非常简单了， 直接在线程设置优先级的时候调用thread_yield即可， 这样就把当前线程重新丢到就绪队列中继续执行， 保证了执行顺序。</p>
<p>此外， 还有在创建线程的时候， 如果新创建的线程比主线程优先级高的话也要调用thread_yield。</p>
<p>实现代码：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Sets the current thread's priority to NEW_PRIORITY. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">3</span> thread_set_priority (<span style="color: #0000ff;">int</span><span style="color: #000000;"> new_priority)
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   thread_current ()-&gt;priority =<span style="color: #000000;"> new_priority;
</span><span style="color: #008080;">6</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;">7</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后在thread_create最后把创建的线程unblock了之后加上这些代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   <span style="color: #0000ff;">if</span> (thread_current ()-&gt;priority &lt;<span style="color: #000000;"> priority)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">3</span> <span style="color: #000000;">    thread_yield ();
</span><span style="color: #008080;">4</span>   }</pre>
</div>
<p>然后就搞定了，总共就加了5行代码。</p>
<p>可能有人会想2个test总共才加了5行代码，这个会不会太简单了。</p>
<p>其实不会，实现这个解决方案的前提是对这个调度机制有清楚的认识，对测试有充分完整的分析。</p>
<p>来看测试结果：</p>
<p>&nbsp;<img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/222132554067915.png" alt=""></p>
<p><span style="line-height: 1.5;">&nbsp;然后就兴高采烈的把priority_change和priority_preempt给pass了，好我们来继续搞别的测试~</span></p>
<p>&nbsp;</p>
<p>接下来我们来把priority-priority-*给过了，这个测试是优先级捐赠的测试，下面我们来分析一下：</p>
<p>这个是一个<span style="color: #ff0000;">优先级翻转(priority inversion)</span>问题:</p>
<p><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/261608290569047.jpg" alt=""></p>
<p>线程 A,B,C 分别具有 1,2,3 优先级(数字越大说明优先级越高), 线程 A,B 目前在就绪队列中等待调度, 线程 A 对一个互斥资源拥有线程锁。而此时, 高优先级的线程 C 也想要访问这个互斥资源, 线程 C 只好在这个资源上等待,不能进入就绪队列。当调度器开始调度时,&nbsp;它只能从 A 和 B 中进行选择,根据优先级调度原理,线程 B 将会首先运行。</p>
<p>这时就产生了一个问题, 即本来线程 C 优先级比线程 B 高, 但是线程 B 却先运行了,从而产生了优先级翻转问题。(<span style="color: #ff0000;">这里复制了课程TA的原话</span>)</p>
<p>&nbsp;</p>
<p>怎么解决这个问题？&nbsp;</p>
<p>当发现高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。</p>
<p>继续TDD走起， 先来看priority-donate-one测试代码：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_donate_one (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> <span style="color: #0000ff;">lock</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure our priority is the default. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>   ASSERT (thread_get_priority () ==<span style="color: #000000;"> PRI_DEFAULT);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   lock_init (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">13</span>   lock_acquire (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">14</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">acquire1</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">1</span>, acquire1_thread_func, &amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">This thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">16</span>        PRI_DEFAULT + <span style="color: #800080;">1</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">17</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">acquire2</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">2</span>, acquire2_thread_func, &amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">18</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">This thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">19</span>        PRI_DEFAULT + <span style="color: #800080;">2</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">20</span>   lock_release (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">21</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire2, acquire1 must already have finished, in that order.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">22</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">This should be the last line before finishing this test.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">23</span> <span style="color: #000000;">}
</span><span style="color: #008080;">24</span> 
<span style="color: #008080;">25</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">26</span> acquire1_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">27</span> <span style="color: #000000;">{
</span><span style="color: #008080;">28</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">29</span> 
<span style="color: #008080;">30</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">31</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire1: got the lock</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">32</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">33</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire1: done</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">34</span> <span style="color: #000000;">}
</span><span style="color: #008080;">35</span> 
<span style="color: #008080;">36</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">37</span> acquire2_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">38</span> <span style="color: #000000;">{
</span><span style="color: #008080;">39</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">40</span> 
<span style="color: #008080;">41</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">42</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire2: got the lock</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">43</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">44</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire2: done</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">45</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>分析： 首先当前线程（称为original_thread）是一个优先级为PRI_DEFAULT的线程， 然后第4行创建了一个锁， 接着创建一个线程acquire1，优先级为PRI_DEFAULT+1, 传了一个参数为这个锁的函数过去（线程acquire1执行的时候会调用）。</p>
<p>好， 我们之前实现的抢占式调度会让acquire1马上执行， 来看acquire1_thread_func干了什么， 这里直接获取了这个锁， 来看lock_acquire函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Acquires LOCK, sleeping until it becomes available if
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   necessary.  The lock must not already be held by the current
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   thread.
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span> <span style="color: #008000;">   This function may sleep, so it must not be called within an
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">   interrupt handler.  This function may be called with
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">   interrupts disabled, but interrupts will be turned back on if
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">   we need to sleep. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">10</span> lock_acquire (<span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span><span style="color: #000000;">)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">{
</span><span style="color: #008080;">12</span>   ASSERT (<span style="color: #0000ff;">lock</span> !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">13</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;">14</span>   ASSERT (!lock_held_by_current_thread (<span style="color: #0000ff;">lock</span><span style="color: #000000;">));
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>   sema_down (&amp;<span style="color: #0000ff;">lock</span>-&gt;<span style="color: #000000;">semaphore);
</span><span style="color: #008080;">17</span>   <span style="color: #0000ff;">lock</span>-&gt;holder =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;">18</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里如我们所想， 直接调用信号量PV操作中的<span style="color: #ff0000;">P操作</span>， 来看P操作sema_down：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Down or "P" operation on a semaphore.  Waits for SEMA's value
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   to become positive and then atomically decrements it.
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #008000;">   This function may sleep, so it must not be called within an
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">   interrupt handler.  This function may be called with
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">   interrupts disabled, but if it sleeps then the next scheduled
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">   thread will probably turn interrupts back on. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 8</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 9</span> sema_down (<span style="color: #0000ff;">struct</span> semaphore *<span style="color: #000000;">sema) 
</span><span style="color: #008080;">10</span> <span style="color: #000000;">{
</span><span style="color: #008080;">11</span>   <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level old_level;
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   ASSERT (sema !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">14</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>   old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">17</span>   <span style="color: #0000ff;">while</span> (sema-&gt;value == <span style="color: #800080;">0</span><span style="color: #000000;">) 
</span><span style="color: #008080;">18</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">19</span>       list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;<span style="color: #000000;">elem);
</span><span style="color: #008080;">20</span> <span style="color: #000000;">      thread_block ();
</span><span style="color: #008080;">21</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">22</span>   sema-&gt;value--<span style="color: #000000;">;
</span><span style="color: #008080;">23</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">24</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>和课上描述的一致， 把线程丢到这个信号量的队列waiters里， 阻塞该线程等待唤醒， value--。</p>
<p>注意， 这里acquire1_thread_func阻塞了， msg这个时候并不会输出， 这时会继续执行original_thread, 然后输出msg， 输出当前线程应该的优先级和实际的优先级。</p>
<p>然后继续创建一个线程acquire2, 优先级为PRI_DEFAULT+2， 这里调用和acquire1一致， 然后original_thread继续输出msg。</p>
<p>好， 然后original_thread释放了这个锁（<span style="color: #ff0000;">V操作</span>）， 释放的过程会触发被锁着的线程acquire1, acquire2， 然后根据优先级调度， 先执行acquire2, 再acquire1, 最后再执行original_thread。</p>
<p>那么这里应该是acquire2, acquire1分别释放锁然后输出msg， 最后original_thread再输出msg。</p>
<p>好， 我们已经把这个测试程序分析完了， 我们来看它希望的输出：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> # -*- perl -*-
<span style="color: #008080;"> 2</span> <span style="color: #000000;">use strict;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">use warnings;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">use tests::tests;
</span><span style="color: #008080;"> 5</span> check_expected ([&lt;&lt;<span style="color: #800000;">'</span><span style="color: #800000;">EOF</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
</span><span style="color: #008080;"> 6</span> (priority-donate-<span style="color: #000000;">one) begin
</span><span style="color: #008080;"> 7</span> (priority-donate-one) This thread should have priority <span style="color: #800080;">32</span>.  Actual priority: <span style="color: #800080;">32</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 8</span> (priority-donate-one) This thread should have priority <span style="color: #800080;">33</span>.  Actual priority: <span style="color: #800080;">33</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 9</span> (priority-donate-one) acquire2: got the <span style="color: #0000ff;">lock</span>
<span style="color: #008080;">10</span> (priority-donate-<span style="color: #000000;">one) acquire2: done
</span><span style="color: #008080;">11</span> (priority-donate-one) acquire1: got the <span style="color: #0000ff;">lock</span>
<span style="color: #008080;">12</span> (priority-donate-<span style="color: #000000;">one) acquire1: done
</span><span style="color: #008080;">13</span> (priority-donate-one) acquire2, acquire1 must already have finished, <span style="color: #0000ff;">in</span><span style="color: #000000;"> that order.
</span><span style="color: #008080;">14</span> (priority-donate-one) This should be the last line before finishing <span style="color: #0000ff;">this</span><span style="color: #000000;"> test.
</span><span style="color: #008080;">15</span> (priority-donate-<span style="color: #000000;">one) end
</span><span style="color: #008080;">16</span> <span style="color: #000000;">EOF
</span><span style="color: #008080;">17</span> pass;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>输出行为和我们分析的一致， 来看7,8行， original_thread的优先级分别变成了PRI_DEFAULT+1和PRI_DEFAULT+2。</p>
<p>我们来根据这个结果分析一下优先级捐赠行为：</p>
<p>original_thread拥有的锁被acquire1获取之后， 因为acquire1线程被阻塞于这个锁， 那么acquire1的执行必须要original_thread继续执行释放这个锁， 从优先级的角度来说， original_thread的优先级应该提升到acquire1的优先级，</p>
<p>因为original_thread本身的执行包含了acquire1执行的阻塞， 所以此时acquire1对original_thread做了捐赠， 优先级提到PRI_DEFAULT+1， acquire2行为类似。</p>
<p>&nbsp;</p>
<p>好， 支持priority-donate-one分析结束， 我们来分析一下实现：</p>
<p>具体行为肯定是被锁定在了锁的获取和释放上了， 我们的实现思路是：</p>
<p><span style="color: #ff0000;">在一个线程获取一个锁的时候， 如果拥有这个锁的线程优先级比自己低就提高它的优先级，然后在这个线程释放掉这个锁之后把原来拥有这个锁的线程改回原来的优先级。</span></p>
<p>&nbsp;</p>
<p><span style="line-height: 1.5;">好， 这里先不急着写代码， 继续来分析其他测试， 全部分析完了再写代码， 因为这些测试都是优先级捐献相关的行为， 我们全部分析完了再写就避免了走弯路了。</span></p>
<p><span style="line-height: 1.5;">来分析测试priority-donte-multiple:</span></p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_donate_multiple (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span><span style="color: #000000;"> a, b;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure our priority is the default. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>   ASSERT (thread_get_priority () ==<span style="color: #000000;"> PRI_DEFAULT);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   lock_init (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">13</span>   lock_init (&amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>   lock_acquire (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">16</span>   lock_acquire (&amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">1</span>, a_thread_func, &amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">19</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">20</span>        PRI_DEFAULT + <span style="color: #800080;">1</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">b</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">2</span>, b_thread_func, &amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">23</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">24</span>        PRI_DEFAULT + <span style="color: #800080;">2</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span>   lock_release (&amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">27</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread b should have just finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">28</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">29</span>        PRI_DEFAULT + <span style="color: #800080;">1</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">30</span> 
<span style="color: #008080;">31</span>   lock_release (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">32</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread a should have just finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">33</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">34</span> <span style="color: #000000;">       PRI_DEFAULT, thread_get_priority ());
</span><span style="color: #008080;">35</span> <span style="color: #000000;">}
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">38</span> a_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">39</span> <span style="color: #000000;">{
</span><span style="color: #008080;">40</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">41</span> 
<span style="color: #008080;">42</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">43</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread a acquired lock a.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">44</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">45</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread a finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">46</span> <span style="color: #000000;">}
</span><span style="color: #008080;">47</span> 
<span style="color: #008080;">48</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">49</span> b_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">50</span> <span style="color: #000000;">{
</span><span style="color: #008080;">51</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">52</span> 
<span style="color: #008080;">53</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">54</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread b acquired lock b.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">55</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">56</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread b finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">57</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>一样， original_thread是优先级为PRI_DEFAULT的线程， 然后创建2个锁， 接着创建优先级为PRI_DEFAULT+1的线程a， 把锁a丢给这个线程的执行函数。</p>
<p>这时候线程a抢占式地调用a_thread_func， 获取了a这个锁， 阻塞。</p>
<p>然后original_thread输出线程优先级的msg。</p>
<p>然后再创建一个线程优先级为PRI_DEFAULT+2的线程b， 和a一样做同样的操作。</p>
<p>好， 然后original_thread释放掉了锁b， 此时线程b被唤醒， 抢占式执行b_thread_func。</p>
<p>然后original再输出msg， a同上， 此时我们来看一下测试希望的输出是什么：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> # -*- perl -*-
<span style="color: #008080;"> 2</span> <span style="color: #000000;">use strict;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">use warnings;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">use tests::tests;
</span><span style="color: #008080;"> 5</span> check_expected ([&lt;&lt;<span style="color: #800000;">'</span><span style="color: #800000;">EOF</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
</span><span style="color: #008080;"> 6</span> (priority-donate-<span style="color: #000000;">multiple) begin
</span><span style="color: #008080;"> 7</span> (priority-donate-multiple) Main thread should have priority <span style="color: #800080;">32</span>.  Actual priority: <span style="color: #800080;">32</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 8</span> (priority-donate-multiple) Main thread should have priority <span style="color: #800080;">33</span>.  Actual priority: <span style="color: #800080;">33</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 9</span> (priority-donate-multiple) Thread b acquired <span style="color: #0000ff;">lock</span><span style="color: #000000;"> b.
</span><span style="color: #008080;">10</span> (priority-donate-<span style="color: #000000;">multiple) Thread b finished.
</span><span style="color: #008080;">11</span> (priority-donate-<span style="color: #000000;">multiple) Thread b should have just finished.
</span><span style="color: #008080;">12</span> (priority-donate-multiple) Main thread should have priority <span style="color: #800080;">32</span>.  Actual priority: <span style="color: #800080;">32</span><span style="color: #000000;">.
</span><span style="color: #008080;">13</span> (priority-donate-multiple) Thread a acquired <span style="color: #0000ff;">lock</span><span style="color: #000000;"> a.
</span><span style="color: #008080;">14</span> (priority-donate-<span style="color: #000000;">multiple) Thread a finished.
</span><span style="color: #008080;">15</span> (priority-donate-<span style="color: #000000;">multiple) Thread a should have just finished.
</span><span style="color: #008080;">16</span> (priority-donate-multiple) Main thread should have priority <span style="color: #800080;">31</span>.  Actual priority: <span style="color: #800080;">31</span><span style="color: #000000;">.
</span><span style="color: #008080;">17</span> (priority-donate-<span style="color: #000000;">multiple) end
</span><span style="color: #008080;">18</span> <span style="color: #000000;">EOF
</span><span style="color: #008080;">19</span> pass;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>好， 这里输出和我们的分析依然是一致的。 重点在于original_thread的优先级变化， 第一次输出是正常的， priority-donate-one已经测试了这个逻辑。</p>
<p>这里特别的是original_thread拥有两把锁分别给a, b两个线程占有了。</p>
<p>后面是释放了b之后， original_thread的优先级恢复到32, 即当前线程的优先级还是被a的优先级所捐赠着的，最后释放了a之后才回到原来的优先级。</p>
<p>这里测试的行为实际是： <span style="color: #ff0000;">多锁情况下优先级逻辑的正确性。</span></p>
<p>那么我们对应的实现思路是： <span style="color: #ff0000;">释放一个锁的时候， 将该锁的拥有者改为该线程被捐赠的第二优先级，若没有其余捐赠者， 则恢复原始优先级。&nbsp;</span></p>
<p>&nbsp;那么我们的线程必然<span style="color: #ff0000;">需要一个数据结构来记录所有对这个线程有捐赠行为的线程</span>。</p>
<p>&nbsp;</p>
<p>继续来看priority-donate-multiple2这个测试：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_donate_multiple2 (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span><span style="color: #000000;"> a, b;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure our priority is the default. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>   ASSERT (thread_get_priority () ==<span style="color: #000000;"> PRI_DEFAULT);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   lock_init (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">13</span>   lock_init (&amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>   lock_acquire (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">16</span>   lock_acquire (&amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">3</span>, a_thread_func, &amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">19</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">20</span>        PRI_DEFAULT + <span style="color: #800080;">3</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">c</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">1</span><span style="color: #000000;">, c_thread_func, NULL);
</span><span style="color: #008080;">23</span> 
<span style="color: #008080;">24</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">b</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">5</span>, b_thread_func, &amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">25</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">26</span>        PRI_DEFAULT + <span style="color: #800080;">5</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span>   lock_release (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">29</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">30</span>        PRI_DEFAULT + <span style="color: #800080;">5</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">31</span> 
<span style="color: #008080;">32</span>   lock_release (&amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">33</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Threads b, a, c should have just finished, in that order.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">34</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">35</span> <span style="color: #000000;">       PRI_DEFAULT, thread_get_priority ());
</span><span style="color: #008080;">36</span> <span style="color: #000000;">}
</span><span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">39</span> a_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">40</span> <span style="color: #000000;">{
</span><span style="color: #008080;">41</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">42</span> 
<span style="color: #008080;">43</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">44</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread a acquired lock a.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">45</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">46</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread a finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">47</span> <span style="color: #000000;">}
</span><span style="color: #008080;">48</span> 
<span style="color: #008080;">49</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">50</span> b_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">51</span> <span style="color: #000000;">{
</span><span style="color: #008080;">52</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">53</span> 
<span style="color: #008080;">54</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">55</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread b acquired lock b.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">56</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">57</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread b finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">58</span> <span style="color: #000000;">}
</span><span style="color: #008080;">59</span> 
<span style="color: #008080;">60</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">61</span> c_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">a_ UNUSED) 
</span><span style="color: #008080;">62</span> <span style="color: #000000;">{
</span><span style="color: #008080;">63</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread c finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">64</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>有了之前的分析这里简单说一下： original_thread拥有2个锁， 然后创建PRI_DEFAULT+3的线程a去拿a这个锁， PRI_DEFAULT+5的线程b去拿b这个锁， 中间创建了一个PRI_DEFAULT+1的c线程， 但是因为创建的时候当前线程的优先级已经被a线程捐赠了所以抢占调度并没有发生。 然后分别释放掉a和b， 释放a的时候线程a被唤醒， 但是优先级依然不如当前线程， 此时当前线程优先级仍然被b捐赠着， 优先级最高继续执行， 然后释放掉b， 释放掉b之后，original_thread的优先级降到初始，应该最后被调用， 线程b抢占调度， 然后线程a， 再是线程c， 最后才original_thread输出msg。</p>
<p>于是就有了以下的输出断言：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> # -*- perl -*-
<span style="color: #008080;"> 2</span> <span style="color: #000000;">use strict;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">use warnings;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">use tests::tests;
</span><span style="color: #008080;"> 5</span> check_expected ([&lt;&lt;<span style="color: #800000;">'</span><span style="color: #800000;">EOF</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
</span><span style="color: #008080;"> 6</span> (priority-donate-<span style="color: #000000;">multiple2) begin
</span><span style="color: #008080;"> 7</span> (priority-donate-multiple2) Main thread should have priority <span style="color: #800080;">34</span>.  Actual priority: <span style="color: #800080;">34</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 8</span> (priority-donate-multiple2) Main thread should have priority <span style="color: #800080;">36</span>.  Actual priority: <span style="color: #800080;">36</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 9</span> (priority-donate-multiple2) Main thread should have priority <span style="color: #800080;">36</span>.  Actual priority: <span style="color: #800080;">36</span><span style="color: #000000;">.
</span><span style="color: #008080;">10</span> (priority-donate-multiple2) Thread b acquired <span style="color: #0000ff;">lock</span><span style="color: #000000;"> b.
</span><span style="color: #008080;">11</span> (priority-donate-<span style="color: #000000;">multiple2) Thread b finished.
</span><span style="color: #008080;">12</span> (priority-donate-multiple2) Thread a acquired <span style="color: #0000ff;">lock</span><span style="color: #000000;"> a.
</span><span style="color: #008080;">13</span> (priority-donate-<span style="color: #000000;">multiple2) Thread a finished.
</span><span style="color: #008080;">14</span> (priority-donate-<span style="color: #000000;">multiple2) Thread c finished.
</span><span style="color: #008080;">15</span> (priority-donate-multiple2) Threads b, a, c should have just finished, <span style="color: #0000ff;">in</span><span style="color: #000000;"> that order.
</span><span style="color: #008080;">16</span> (priority-donate-multiple2) Main thread should have priority <span style="color: #800080;">31</span>.  Actual priority: <span style="color: #800080;">31</span><span style="color: #000000;">.
</span><span style="color: #008080;">17</span> (priority-donate-<span style="color: #000000;">multiple2) end
</span><span style="color: #008080;">18</span> <span style="color: #000000;">EOF
</span><span style="color: #008080;">19</span> pass;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里依然测试的是多锁情况下优先级逻辑的正确性。</p>
<p>&nbsp;</p>
<p>&nbsp;再来看测试priority-donate-nest：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_donate_nest (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span><span style="color: #000000;"> a, b;
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> locks locks;
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 8</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure our priority is the default. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span>   ASSERT (thread_get_priority () ==<span style="color: #000000;"> PRI_DEFAULT);
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   lock_init (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">14</span>   lock_init (&amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>   lock_acquire (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span>   locks.a = &amp;<span style="color: #000000;">a;
</span><span style="color: #008080;">19</span>   locks.b = &amp;<span style="color: #000000;">b;
</span><span style="color: #008080;">20</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">medium</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">1</span>, medium_thread_func, &amp;<span style="color: #000000;">locks);
</span><span style="color: #008080;">21</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;">22</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Low thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">23</span>        PRI_DEFAULT + <span style="color: #800080;">1</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">24</span> 
<span style="color: #008080;">25</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">high</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">2</span>, high_thread_func, &amp;<span style="color: #000000;">b);
</span><span style="color: #008080;">26</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;">27</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Low thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">28</span>        PRI_DEFAULT + <span style="color: #800080;">2</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">29</span> 
<span style="color: #008080;">30</span>   lock_release (&amp;<span style="color: #000000;">a);
</span><span style="color: #008080;">31</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;">32</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Medium thread should just have finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">33</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Low thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">34</span> <span style="color: #000000;">       PRI_DEFAULT, thread_get_priority ());
</span><span style="color: #008080;">35</span> <span style="color: #000000;">}
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">38</span> medium_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">locks_) 
</span><span style="color: #008080;">39</span> <span style="color: #000000;">{
</span><span style="color: #008080;">40</span>   <span style="color: #0000ff;">struct</span> locks *locks =<span style="color: #000000;"> locks_;
</span><span style="color: #008080;">41</span> 
<span style="color: #008080;">42</span>   lock_acquire (locks-&gt;<span style="color: #000000;">b);
</span><span style="color: #008080;">43</span>   lock_acquire (locks-&gt;<span style="color: #000000;">a);
</span><span style="color: #008080;">44</span> 
<span style="color: #008080;">45</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Medium thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">46</span>        PRI_DEFAULT + <span style="color: #800080;">2</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">47</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Medium thread got the lock.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">48</span> 
<span style="color: #008080;">49</span>   lock_release (locks-&gt;<span style="color: #000000;">a);
</span><span style="color: #008080;">50</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;">51</span> 
<span style="color: #008080;">52</span>   lock_release (locks-&gt;<span style="color: #000000;">b);
</span><span style="color: #008080;">53</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;">54</span> 
<span style="color: #008080;">55</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">High thread should have just finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">56</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Middle thread finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">57</span> <span style="color: #000000;">}
</span><span style="color: #008080;">58</span> 
<span style="color: #008080;">59</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">60</span> high_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">61</span> <span style="color: #000000;">{
</span><span style="color: #008080;">62</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">63</span> 
<span style="color: #008080;">64</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">65</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">High thread got the lock.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">66</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">67</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">High thread finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">68</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>注意， original_thread只获取了锁a， 它并不拥有锁b。</p>
<p>这里创建了一个locks的结构体装着2个锁a和b， 然后创建medium线程， 优先级为PRI_DEFAULT+1, 把这个locks作为线程medium执行函数的参数。</p>
<p><span style="line-height: 1.5;">然后抢占调用medium_thread_func， 此时这个函数获取b这个锁， 此时medium成为锁b的拥有者， 并不阻塞， 继续执行， 然后medium在获取锁a的时候阻塞了。</span></p>
<p><span style="line-height: 1.5;">此时original_thread继续跑， 它的优先级被medium提到了PRI_DEFAULT+1, 输出优先级Msg。</span></p>
<p><span style="line-height: 1.5;">然后创建优先级为PRI_DEFAULT+2的high线程， 抢占调用high_thread_func， 然后这里high拿到了b这个锁， 而b的拥有者是medium， 阻塞， 注意， 这里medium被high捐赠了， 优先级到PRI_DEFAULT+2, 此时original_thread也应该一样提到同样优先级。</span></p>
<p><span style="line-height: 1.5;">然后original_thread输出一下优先级msg之后释放掉锁a， 释放出发了medium_thread_func抢占调用， 输出此时优先级为PRI_DEFAULT+2， 然后medium释放掉a, 释放掉b， 释放b的时候被high_thread_func抢占， high输出完之后medium继续run， 输出两句之后再到original_thread， 输出两句msg完事。<br></span></p>
<p><span style="line-height: 1.5;">按照这个逻辑， 它的希望输出也是和我们分析的过程一样：</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> # -*- perl -*-
<span style="color: #008080;"> 2</span> <span style="color: #000000;">use strict;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">use warnings;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">use tests::tests;
</span><span style="color: #008080;"> 5</span> check_expected ([&lt;&lt;<span style="color: #800000;">'</span><span style="color: #800000;">EOF</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
</span><span style="color: #008080;"> 6</span> (priority-donate-<span style="color: #000000;">nest) begin
</span><span style="color: #008080;"> 7</span> (priority-donate-nest) Low thread should have priority <span style="color: #800080;">32</span>.  Actual priority: <span style="color: #800080;">32</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 8</span> (priority-donate-nest) Low thread should have priority <span style="color: #800080;">33</span>.  Actual priority: <span style="color: #800080;">33</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 9</span> (priority-donate-nest) Medium thread should have priority <span style="color: #800080;">33</span>.  Actual priority: <span style="color: #800080;">33</span><span style="color: #000000;">.
</span><span style="color: #008080;">10</span> (priority-donate-nest) Medium thread got the <span style="color: #0000ff;">lock</span><span style="color: #000000;">.
</span><span style="color: #008080;">11</span> (priority-donate-nest) High thread got the <span style="color: #0000ff;">lock</span><span style="color: #000000;">.
</span><span style="color: #008080;">12</span> (priority-donate-<span style="color: #000000;">nest) High thread finished.
</span><span style="color: #008080;">13</span> (priority-donate-<span style="color: #000000;">nest) High thread should have just finished.
</span><span style="color: #008080;">14</span> (priority-donate-<span style="color: #000000;">nest) Middle thread finished.
</span><span style="color: #008080;">15</span> (priority-donate-<span style="color: #000000;">nest) Medium thread should just have finished.
</span><span style="color: #008080;">16</span> (priority-donate-nest) Low thread should have priority <span style="color: #800080;">31</span>.  Actual priority: <span style="color: #800080;">31</span><span style="color: #000000;">.
</span><span style="color: #008080;">17</span> (priority-donate-<span style="color: #000000;">nest) end
</span><span style="color: #008080;">18</span> <span style="color: #000000;">EOF
</span><span style="color: #008080;">19</span> pass;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p>这个测试是一个<span style="color: #ff0000;">优先级嵌套问题， 重点在于medium拥有的锁被low阻塞， 在这个前提下high再去获取medium的说阻塞的话， 优先级提升具有连环效应， 就是medium被提升了， 此时它被锁捆绑的low线程应该跟着一起提升。</span></p>
<p>&nbsp;</p>
<p>&nbsp;从实现的角度来说， 我们线程又<span style="color: #ff0000;">需要加一个数据结构， 我们需要获取这个线程被锁于哪个线程</span>。</p>
<p>&nbsp;</p>
<p>好的， 再看下一个测试priority-donate-sema:</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_donate_sema (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> lock_and_sema ls;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure our priority is the default. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>   ASSERT (thread_get_priority () ==<span style="color: #000000;"> PRI_DEFAULT);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   lock_init (&amp;ls.<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">13</span>   sema_init (&amp;ls.sema, <span style="color: #800080;">0</span><span style="color: #000000;">);
</span><span style="color: #008080;">14</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">low</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">1</span>, l_thread_func, &amp;<span style="color: #000000;">ls);
</span><span style="color: #008080;">15</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">med</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">3</span>, m_thread_func, &amp;<span style="color: #000000;">ls);
</span><span style="color: #008080;">16</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">high</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">5</span>, h_thread_func, &amp;<span style="color: #000000;">ls);
</span><span style="color: #008080;">17</span>   sema_up (&amp;<span style="color: #000000;">ls.sema);
</span><span style="color: #008080;">18</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">}
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">22</span> l_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">ls_) 
</span><span style="color: #008080;">23</span> <span style="color: #000000;">{
</span><span style="color: #008080;">24</span>   <span style="color: #0000ff;">struct</span> lock_and_sema *ls =<span style="color: #000000;"> ls_;
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span>   lock_acquire (&amp;ls-&gt;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">27</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread L acquired lock.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">28</span>   sema_down (&amp;ls-&gt;<span style="color: #000000;">sema);
</span><span style="color: #008080;">29</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread L downed semaphore.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">30</span>   lock_release (&amp;ls-&gt;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">31</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread L finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">32</span> <span style="color: #000000;">}
</span><span style="color: #008080;">33</span> 
<span style="color: #008080;">34</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">35</span> m_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">ls_) 
</span><span style="color: #008080;">36</span> <span style="color: #000000;">{
</span><span style="color: #008080;">37</span>   <span style="color: #0000ff;">struct</span> lock_and_sema *ls =<span style="color: #000000;"> ls_;
</span><span style="color: #008080;">38</span> 
<span style="color: #008080;">39</span>   sema_down (&amp;ls-&gt;<span style="color: #000000;">sema);
</span><span style="color: #008080;">40</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread M finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">41</span> <span style="color: #000000;">}
</span><span style="color: #008080;">42</span> 
<span style="color: #008080;">43</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">44</span> h_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">ls_) 
</span><span style="color: #008080;">45</span> <span style="color: #000000;">{
</span><span style="color: #008080;">46</span>   <span style="color: #0000ff;">struct</span> lock_and_sema *ls =<span style="color: #000000;"> ls_;
</span><span style="color: #008080;">47</span> 
<span style="color: #008080;">48</span>   lock_acquire (&amp;ls-&gt;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">49</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread H acquired lock.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">50</span> 
<span style="color: #008080;">51</span>   sema_up (&amp;ls-&gt;<span style="color: #000000;">sema);
</span><span style="color: #008080;">52</span>   lock_release (&amp;ls-&gt;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">53</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread H finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">54</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>lock_and_sema是包含一个锁和一个信号量的结构体， 初始化信号量为0, 然后创建PRI_DEFAULT+1的线程low, 获取ls内的锁成为拥有者， 然后sema_down（P）阻塞。&nbsp;</p>
<p>然后创建PRI_DEFAULT+3的线程med， 这里也直接调用sema_down(P)阻塞了。</p>
<p>最后创建PRI_DEFAULT+5的线程high, 这里获取锁， 阻塞。</p>
<p>然后回到original_thread， 调用V操作， 此时唤醒了l_thread_func， 因为low被high捐献了优先级高于med， 然后l_thread_func跑， 释放掉了锁。</p>
<p>此时直接触发h_thread_func， 输出， 然后V操作， 释放掉锁， 由于优先级最高所以V操作之后不会被抢占， 这个函数跑完之后m_thread_func开始跑（被V唤醒）， 然后输出一句完事， 再到l_thread_func中输出最后一句回到original_thread。</p>
<p>这里包含了信号量和锁混合触发， 实际上还是信号量在起作用， 因为锁是由信号量实现的。</p>
<p>所以输出是这样的：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> # -*- perl -*-
<span style="color: #008080;"> 2</span> <span style="color: #000000;">use strict;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">use warnings;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">use tests::tests;
</span><span style="color: #008080;"> 5</span> check_expected ([&lt;&lt;<span style="color: #800000;">'</span><span style="color: #800000;">EOF</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
</span><span style="color: #008080;"> 6</span> (priority-donate-<span style="color: #000000;">sema) begin
</span><span style="color: #008080;"> 7</span> (priority-donate-sema) Thread L acquired <span style="color: #0000ff;">lock</span><span style="color: #000000;">.
</span><span style="color: #008080;"> 8</span> (priority-donate-<span style="color: #000000;">sema) Thread L downed semaphore.
</span><span style="color: #008080;"> 9</span> (priority-donate-sema) Thread H acquired <span style="color: #0000ff;">lock</span><span style="color: #000000;">.
</span><span style="color: #008080;">10</span> (priority-donate-<span style="color: #000000;">sema) Thread H finished.
</span><span style="color: #008080;">11</span> (priority-donate-<span style="color: #000000;">sema) Thread M finished.
</span><span style="color: #008080;">12</span> (priority-donate-<span style="color: #000000;">sema) Thread L finished.
</span><span style="color: #008080;">13</span> (priority-donate-<span style="color: #000000;">sema) Main thread finished.
</span><span style="color: #008080;">14</span> (priority-donate-<span style="color: #000000;">sema) end
</span><span style="color: #008080;">15</span> <span style="color: #000000;">EOF
</span><span style="color: #008080;">16</span> pass;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p>再来看priority-donate-lower:</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_donate_lower (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> <span style="color: #0000ff;">lock</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Make sure our priority is the default. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>   ASSERT (thread_get_priority () ==<span style="color: #000000;"> PRI_DEFAULT);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   lock_init (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">13</span>   lock_acquire (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">14</span>   thread_create (<span style="color: #800000;">"</span><span style="color: #800000;">acquire</span><span style="color: #800000;">"</span>, PRI_DEFAULT + <span style="color: #800080;">10</span>, acquire_thread_func, &amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">16</span>        PRI_DEFAULT + <span style="color: #800080;">10</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Lowering base priority...</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">19</span>   thread_set_priority (PRI_DEFAULT - <span style="color: #800080;">10</span><span style="color: #000000;">);
</span><span style="color: #008080;">20</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">21</span>        PRI_DEFAULT + <span style="color: #800080;">10</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">22</span>   lock_release (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">23</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire must already have finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">24</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Main thread should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">25</span>        PRI_DEFAULT - <span style="color: #800080;">10</span><span style="color: #000000;">, thread_get_priority ());
</span><span style="color: #008080;">26</span> <span style="color: #000000;">}
</span><span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">29</span> acquire_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">lock_) 
</span><span style="color: #008080;">30</span> <span style="color: #000000;">{
</span><span style="color: #008080;">31</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span> =<span style="color: #000000;"> lock_;
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">34</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire: got the lock</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">35</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">36</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">acquire: done</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">37</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;这里当前线程有一个锁， 然后创建acquire抢占式获取了这个锁阻塞， 然后此时original_thread优先级为PRI_DEFAULT+10， 然后这里调用thread_set_priority， 此时当前线程的优先级应该没有改变， 但是它以后如果恢复优先级时候其实是有改变的， 就是说， 我们如果用original_priority来记录他的话， 如果这个线程处于被捐赠状态的话则直接修改original_priority来完成逻辑， 此时函数过后优先级还是PRI_DEFAULT+10， 然后释放掉锁， acquire抢占输出和释放， 然后original_thread的优先级应该变成了PRI_DEFAULT-10。</p>
<p>这里测试的逻辑是<span style="color: #ff0000;">当修改一个被捐赠的线程优先级的时候的行为正确性</span>。</p>
<p>&nbsp;</p>
<p>还剩下最后3个测试分析， 先看priority-sema：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_sema (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;"> 5</span>   
<span style="color: #008080;"> 6</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   sema_init (&amp;sema, <span style="color: #800080;">0</span><span style="color: #000000;">);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">  thread_set_priority (PRI_MIN);
</span><span style="color: #008080;">11</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; i++<span style="color: #000000;">) 
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">13</span>       <span style="color: #0000ff;">int</span> priority = PRI_DEFAULT - (i + <span style="color: #800080;">3</span>) % <span style="color: #800080;">10</span> - <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">14</span>       <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">16</span><span style="color: #000000;">];
</span><span style="color: #008080;">15</span>       snprintf (name, <span style="color: #0000ff;">sizeof</span> name, <span style="color: #800000;">"</span><span style="color: #800000;">priority %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, priority);
</span><span style="color: #008080;">16</span> <span style="color: #000000;">      thread_create (name, priority, priority_sema_thread, NULL);
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; i++<span style="color: #000000;">) 
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">21</span>       sema_up (&amp;<span style="color: #000000;">sema);
</span><span style="color: #008080;">22</span>       msg (<span style="color: #800000;">"</span><span style="color: #800000;">Back in main thread.</span><span style="color: #800000;">"</span><span style="color: #000000;">); 
</span><span style="color: #008080;">23</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">24</span> <span style="color: #000000;">}
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">27</span> priority_sema_thread (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED) 
</span><span style="color: #008080;">28</span> <span style="color: #000000;">{
</span><span style="color: #008080;">29</span>   sema_down (&amp;<span style="color: #000000;">sema);
</span><span style="color: #008080;">30</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread %s woke up.</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name ());
</span><span style="color: #008080;">31</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里创建10个线程阻塞于P操作， 然后用一个循环V操作， 然后看结果：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> # -*- perl -*-
<span style="color: #008080;"> 2</span> <span style="color: #000000;">use strict;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">use warnings;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">use tests::tests;
</span><span style="color: #008080;"> 5</span> check_expected ([&lt;&lt;<span style="color: #800000;">'</span><span style="color: #800000;">EOF</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
</span><span style="color: #008080;"> 6</span> (priority-<span style="color: #000000;">sema) begin
</span><span style="color: #008080;"> 7</span> (priority-sema) Thread priority <span style="color: #800080;">30</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;"> 8</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;"> 9</span> (priority-sema) Thread priority <span style="color: #800080;">29</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">10</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">11</span> (priority-sema) Thread priority <span style="color: #800080;">28</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">12</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">13</span> (priority-sema) Thread priority <span style="color: #800080;">27</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">14</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">15</span> (priority-sema) Thread priority <span style="color: #800080;">26</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">16</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">17</span> (priority-sema) Thread priority <span style="color: #800080;">25</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">18</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">19</span> (priority-sema) Thread priority <span style="color: #800080;">24</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">20</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">21</span> (priority-sema) Thread priority <span style="color: #800080;">23</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">22</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">23</span> (priority-sema) Thread priority <span style="color: #800080;">22</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">24</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">25</span> (priority-sema) Thread priority <span style="color: #800080;">21</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">26</span> (priority-sema) Back <span style="color: #0000ff;">in</span><span style="color: #000000;"> main thread.
</span><span style="color: #008080;">27</span> (priority-<span style="color: #000000;">sema) end
</span><span style="color: #008080;">28</span> <span style="color: #000000;">EOF
</span><span style="color: #008080;">29</span> pass;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>好， 也就是说V唤醒的时候也是优先级高的先唤醒， 换句话说， <span style="color: #ff0000;">信号量的等待队列是优先级队列</span>。</p>
<p>&nbsp;</p>
<p>再看priority-condvar测试：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_condvar (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;"> 5</span>   
<span style="color: #008080;"> 6</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   lock_init (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">10</span>   cond_init (&amp;<span style="color: #000000;">condition);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span> <span style="color: #000000;">  thread_set_priority (PRI_MIN);
</span><span style="color: #008080;">13</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; i++<span style="color: #000000;">) 
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">15</span>       <span style="color: #0000ff;">int</span> priority = PRI_DEFAULT - (i + <span style="color: #800080;">7</span>) % <span style="color: #800080;">10</span> - <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">16</span>       <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">16</span><span style="color: #000000;">];
</span><span style="color: #008080;">17</span>       snprintf (name, <span style="color: #0000ff;">sizeof</span> name, <span style="color: #800000;">"</span><span style="color: #800000;">priority %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, priority);
</span><span style="color: #008080;">18</span> <span style="color: #000000;">      thread_create (name, priority, priority_condvar_thread, NULL);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; i++<span style="color: #000000;">) 
</span><span style="color: #008080;">22</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">23</span>       lock_acquire (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">24</span>       msg (<span style="color: #800000;">"</span><span style="color: #800000;">Signaling...</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">25</span>       cond_signal (&amp;condition, &amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">26</span>       lock_release (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">27</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">28</span> <span style="color: #000000;">}
</span><span style="color: #008080;">29</span> 
<span style="color: #008080;">30</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">31</span> priority_condvar_thread (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED) 
</span><span style="color: #008080;">32</span> <span style="color: #000000;">{
</span><span style="color: #008080;">33</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread %s starting.</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name ());
</span><span style="color: #008080;">34</span>   lock_acquire (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">35</span>   cond_wait (&amp;condition, &amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">36</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">Thread %s woke up.</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name ());
</span><span style="color: #008080;">37</span>   lock_release (&amp;<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">38</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;这里condition里面装的是一个waiters队列， 看一下con_wait和cond_signal函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Atomically releases LOCK and waits for COND to be signaled by
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">   some other piece of code.  After COND is signaled, LOCK is
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">   reacquired before returning.  LOCK must be held before calling
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">   this function.
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #008000;">   The monitor implemented by this function is "Mesa" style, not
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">   "Hoare" style, that is, sending and receiving a signal are not
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">   an atomic operation.  Thus, typically the caller must recheck
</span><span style="color: #008080;"> 9</span> <span style="color: #008000;">   the condition after the wait completes and, if necessary, wait
</span><span style="color: #008080;">10</span> <span style="color: #008000;">   again.
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span> <span style="color: #008000;">   A given condition variable is associated with only a single
</span><span style="color: #008080;">13</span> <span style="color: #008000;">   lock, but one lock may be associated with any number of
</span><span style="color: #008080;">14</span> <span style="color: #008000;">   condition variables.  That is, there is a one-to-many mapping
</span><span style="color: #008080;">15</span> <span style="color: #008000;">   from locks to condition variables.
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #008000;">   This function may sleep, so it must not be called within an
</span><span style="color: #008080;">18</span> <span style="color: #008000;">   interrupt handler.  This function may be called with
</span><span style="color: #008080;">19</span> <span style="color: #008000;">   interrupts disabled, but interrupts will be turned back on if
</span><span style="color: #008080;">20</span> <span style="color: #008000;">   we need to sleep. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">21</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">22</span> cond_wait (<span style="color: #0000ff;">struct</span> condition *cond, <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span><span style="color: #000000;">)
</span><span style="color: #008080;">23</span> <span style="color: #000000;">{
</span><span style="color: #008080;">24</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> semaphore_elem waiter;
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span>   ASSERT (cond !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">27</span>   ASSERT (<span style="color: #0000ff;">lock</span> !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">28</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;">29</span>   ASSERT (lock_held_by_current_thread (<span style="color: #0000ff;">lock</span><span style="color: #000000;">));
</span><span style="color: #008080;">30</span> 
<span style="color: #008080;">31</span>   sema_init (&amp;waiter.semaphore, <span style="color: #800080;">0</span><span style="color: #000000;">);
</span><span style="color: #008080;">32</span>   list_push_back (&amp;cond-&gt;waiters, &amp;<span style="color: #000000;">waiter.elem);
</span><span style="color: #008080;">33</span>   lock_release (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">34</span>   sema_down (&amp;<span style="color: #000000;">waiter.semaphore);
</span><span style="color: #008080;">35</span>   lock_acquire (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">36</span> <span style="color: #000000;">}
</span><span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> If any threads are waiting on COND (protected by LOCK), then
</span><span style="color: #008080;">39</span> <span style="color: #008000;">   this function signals one of them to wake up from its wait.
</span><span style="color: #008080;">40</span> <span style="color: #008000;">   LOCK must be held before calling this function.
</span><span style="color: #008080;">41</span> 
<span style="color: #008080;">42</span> <span style="color: #008000;">   An interrupt handler cannot acquire a lock, so it does not
</span><span style="color: #008080;">43</span> <span style="color: #008000;">   make sense to try to signal a condition variable within an
</span><span style="color: #008080;">44</span> <span style="color: #008000;">   interrupt handler. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">45</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">46</span> cond_signal (<span style="color: #0000ff;">struct</span> condition *cond, <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span><span style="color: #000000;"> UNUSED)
</span><span style="color: #008080;">47</span> <span style="color: #000000;">{
</span><span style="color: #008080;">48</span>   ASSERT (cond !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">49</span>   ASSERT (<span style="color: #0000ff;">lock</span> !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;">50</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;">51</span>   ASSERT (lock_held_by_current_thread (<span style="color: #0000ff;">lock</span><span style="color: #000000;">));
</span><span style="color: #008080;">52</span> 
<span style="color: #008080;">53</span>   <span style="color: #0000ff;">if</span> (!list_empty (&amp;cond-&gt;<span style="color: #000000;">waiters))
</span><span style="color: #008080;">54</span>     sema_up (&amp;list_entry (list_pop_front (&amp;cond-&gt;<span style="color: #000000;">waiters),
</span><span style="color: #008080;">55</span>                           <span style="color: #0000ff;">struct</span> semaphore_elem, elem)-&gt;<span style="color: #000000;">semaphore);
</span><span style="color: #008080;">56</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>分析： cond_wait和cond_signal就是释放掉锁， 等待signal唤醒， 然后再重新获取锁。</p>
<p>这里的代码逻辑是： 创建10个线程， 每个线程调用的时候获取锁， 然后调用cond_wait把锁释放阻塞于cond_signal唤醒， 然后连续10次循环调用cond_signal。</p>
<p>来看输出：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> # -*- perl -*-
<span style="color: #008080;"> 2</span> <span style="color: #000000;">use strict;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">use warnings;
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">use tests::tests;
</span><span style="color: #008080;"> 5</span> check_expected ([&lt;&lt;<span style="color: #800000;">'</span><span style="color: #800000;">EOF</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
</span><span style="color: #008080;"> 6</span> (priority-<span style="color: #000000;">condvar) begin
</span><span style="color: #008080;"> 7</span> (priority-condvar) Thread priority <span style="color: #800080;">23</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;"> 8</span> (priority-condvar) Thread priority <span style="color: #800080;">22</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;"> 9</span> (priority-condvar) Thread priority <span style="color: #800080;">21</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">10</span> (priority-condvar) Thread priority <span style="color: #800080;">30</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">11</span> (priority-condvar) Thread priority <span style="color: #800080;">29</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">12</span> (priority-condvar) Thread priority <span style="color: #800080;">28</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">13</span> (priority-condvar) Thread priority <span style="color: #800080;">27</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">14</span> (priority-condvar) Thread priority <span style="color: #800080;">26</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">15</span> (priority-condvar) Thread priority <span style="color: #800080;">25</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">16</span> (priority-condvar) Thread priority <span style="color: #800080;">24</span><span style="color: #000000;"> starting.
</span><span style="color: #008080;">17</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">18</span> (priority-condvar) Thread priority <span style="color: #800080;">30</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">19</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">20</span> (priority-condvar) Thread priority <span style="color: #800080;">29</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">21</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">22</span> (priority-condvar) Thread priority <span style="color: #800080;">28</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">23</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">24</span> (priority-condvar) Thread priority <span style="color: #800080;">27</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">25</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">26</span> (priority-condvar) Thread priority <span style="color: #800080;">26</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">27</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">28</span> (priority-condvar) Thread priority <span style="color: #800080;">25</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">29</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">30</span> (priority-condvar) Thread priority <span style="color: #800080;">24</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">31</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">32</span> (priority-condvar) Thread priority <span style="color: #800080;">23</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">33</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">34</span> (priority-condvar) Thread priority <span style="color: #800080;">22</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">35</span> (priority-<span style="color: #000000;">condvar) Signaling...
</span><span style="color: #008080;">36</span> (priority-condvar) Thread priority <span style="color: #800080;">21</span><span style="color: #000000;"> woke up.
</span><span style="color: #008080;">37</span> (priority-<span style="color: #000000;">condvar) end
</span><span style="color: #008080;">38</span> <span style="color: #000000;">EOF
</span><span style="color: #008080;">39</span> pass;</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>从结果来看， 这里要求的实质就是： <span style="color: #ff0000;">condition的waiters队列是优先级队列</span></p>
<p>&nbsp;</p>
<p>好， 来看最后一个测试priority-donate-chain：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> test_priority_donate_chain (<span style="color: #0000ff;">void</span><span style="color: #000000;">) 
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;  
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> locks[NESTING_DEPTH - <span style="color: #800080;">1</span><span style="color: #000000;">];
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> lock_pair lock_pairs[NESTING_DEPTH];
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> This test does not work with the MLFQS. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span>   ASSERT (!<span style="color: #000000;">thread_mlfqs);
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> <span style="color: #000000;">  thread_set_priority (PRI_MIN);
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; NESTING_DEPTH - <span style="color: #800080;">1</span>; i++<span style="color: #000000;">)
</span><span style="color: #008080;">14</span>     lock_init (&amp;<span style="color: #000000;">locks[i]);
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>   lock_acquire (&amp;locks[<span style="color: #800080;">0</span><span style="color: #000000;">]);
</span><span style="color: #008080;">17</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">%s got lock.</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name ());
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>   <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">1</span>; i &lt; NESTING_DEPTH; i++<span style="color: #000000;">)
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">21</span>       <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">16</span><span style="color: #000000;">];
</span><span style="color: #008080;">22</span>       <span style="color: #0000ff;">int</span><span style="color: #000000;"> thread_priority;
</span><span style="color: #008080;">23</span> 
<span style="color: #008080;">24</span>       snprintf (name, <span style="color: #0000ff;">sizeof</span> name, <span style="color: #800000;">"</span><span style="color: #800000;">thread %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, i);
</span><span style="color: #008080;">25</span>       thread_priority = PRI_MIN + i * <span style="color: #800080;">3</span><span style="color: #000000;">;
</span><span style="color: #008080;">26</span>       lock_pairs[i].first = i &lt; NESTING_DEPTH - <span style="color: #800080;">1</span> ? locks +<span style="color: #000000;"> i: NULL;
</span><span style="color: #008080;">27</span>       lock_pairs[i].second = locks + i - <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span>       thread_create (name, thread_priority, donor_thread_func, lock_pairs +<span style="color: #000000;"> i);
</span><span style="color: #008080;">30</span>       msg (<span style="color: #800000;">"</span><span style="color: #800000;">%s should have priority %d.  Actual priority: %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">31</span> <span style="color: #000000;">          thread_name (), thread_priority, thread_get_priority ());
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span>       snprintf (name, <span style="color: #0000ff;">sizeof</span> name, <span style="color: #800000;">"</span><span style="color: #800000;">interloper %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, i);
</span><span style="color: #008080;">34</span>       thread_create (name, thread_priority - <span style="color: #800080;">1</span><span style="color: #000000;">, interloper_thread_func, NULL);
</span><span style="color: #008080;">35</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span>   lock_release (&amp;locks[<span style="color: #800080;">0</span><span style="color: #000000;">]);
</span><span style="color: #008080;">38</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">%s finishing with priority %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name (),
</span><span style="color: #008080;">39</span> <span style="color: #000000;">                                         thread_get_priority ());
</span><span style="color: #008080;">40</span> <span style="color: #000000;">}
</span><span style="color: #008080;">41</span> 
<span style="color: #008080;">42</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">43</span> donor_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">locks_) 
</span><span style="color: #008080;">44</span> <span style="color: #000000;">{
</span><span style="color: #008080;">45</span>   <span style="color: #0000ff;">struct</span> lock_pair *locks =<span style="color: #000000;"> locks_;
</span><span style="color: #008080;">46</span> 
<span style="color: #008080;">47</span>   <span style="color: #0000ff;">if</span> (locks-&gt;<span style="color: #000000;">first)
</span><span style="color: #008080;">48</span>     lock_acquire (locks-&gt;<span style="color: #000000;">first);
</span><span style="color: #008080;">49</span> 
<span style="color: #008080;">50</span>   lock_acquire (locks-&gt;<span style="color: #000000;">second);
</span><span style="color: #008080;">51</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">%s got lock</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name ());
</span><span style="color: #008080;">52</span> 
<span style="color: #008080;">53</span>   lock_release (locks-&gt;<span style="color: #000000;">second);
</span><span style="color: #008080;">54</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">%s should have priority %d. Actual priority: %d</span><span style="color: #800000;">"</span><span style="color: #000000;">, 
</span><span style="color: #008080;">55</span>         thread_name (), (NESTING_DEPTH - <span style="color: #800080;">1</span>) * <span style="color: #800080;">3</span><span style="color: #000000;">,
</span><span style="color: #008080;">56</span> <span style="color: #000000;">        thread_get_priority ());
</span><span style="color: #008080;">57</span> 
<span style="color: #008080;">58</span>   <span style="color: #0000ff;">if</span> (locks-&gt;<span style="color: #000000;">first)
</span><span style="color: #008080;">59</span>     lock_release (locks-&gt;<span style="color: #000000;">first);
</span><span style="color: #008080;">60</span> 
<span style="color: #008080;">61</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">%s finishing with priority %d.</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name (),
</span><span style="color: #008080;">62</span> <span style="color: #000000;">                                         thread_get_priority ());
</span><span style="color: #008080;">63</span> <span style="color: #000000;">}
</span><span style="color: #008080;">64</span> 
<span style="color: #008080;">65</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">66</span> interloper_thread_func (<span style="color: #0000ff;">void</span> *<span style="color: #000000;">arg_ UNUSED)
</span><span style="color: #008080;">67</span> <span style="color: #000000;">{
</span><span style="color: #008080;">68</span>   msg (<span style="color: #800000;">"</span><span style="color: #800000;">%s finished.</span><span style="color: #800000;">"</span><span style="color: #000000;">, thread_name ());
</span><span style="color: #008080;">69</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;首先lock_pair是包含两个lock指针的结构体， 然后将当前线程优先级设为PRI_MIN， 然后这里有个locks数组， 容量为7, 然后lock_pairs数组用来装lock_pair， 容量也是7。</p>
<p>然后当前线程获取locks[0]这个锁， 接着跳到7次循环里， 每次循环thread_priority为PRI_MIN+i*3， 也就是3,6,9,12... 然后对应的lock_pairs[i]的first记录locks[i]的指针， second记录locks[i-1]指针，</p>
<p>然后创建线程， 优先级为thread_priority, 执行参数传的是&amp;lock_pairs[i]， 注意这里由于优先级每次都底层， 所以每次循环都会抢占调用donor_thread_func， 然后分别获取lock_pairs[i]里装的锁， 然后每次循环先获取first, 即locks[i], 然后获取second, 由于second是前一个， 而前一个的拥有者一定是前一次循环创建的线程， 第一次拿得的是locks[0]， 最后一次循环first为NULL， second为locks[6]， 即最后一个线程不拥有锁， 但是阻塞于前一个创建的线程， 这里还会输出信息， 即创建的线程阻塞之后会输出当前线程的优先级msg, 当然这里必然是每一次都提升了的， 所以每次都是thread_priority。</p>
<p>然后每次循环最后还创建了1个线程， 优先级为thread_priority-1， 但是这里由于上一个线程创建和阻塞的过程中优先级捐献已经发生， 所以这里并不发生抢占， 只是创建出来了而已。</p>
<p>然后original_thread释放掉locks[0]， 释放掉这个之后thread1得到了唤醒， 输出信息， 释放掉这个锁， 然后输出当前优先级， 由于这个线程还是被后面最高优先级的线程说捐赠的， 所以每次往后优先级都是21, 然后释放掉first， 这里又触发下一个线程继续跑， 注意当后面的全部跑完的时候当前线程的优先级其实是不被捐赠的， 这里就变成了原来的优先级， 但是是所有线程都释放了之后才依次返回输出结束msg。</p>
<p>这个测试其实就是一个链式优先级捐赠， 本质测试的还是<span style="color: #ff0000;">多层优先级捐赠逻辑的正确性</span>。</p>
<p>需要注意的是一个逻辑： 释放掉一个锁之后， 如果当前线程不被捐赠即马上改为原来的优先级， 抢占式调度。</p>
<p>&nbsp;</p>
<p>好， 我们把所有priority相关的测试都分析了个遍， 现在再来写代码实现这些测试逻辑就是很简单的事情了， 来搞～</p>
<p>先总结一下所有测试整合的逻辑：</p>
<p>1. &nbsp;在一个线程获取一个锁的时候， 如果拥有这个锁的线程优先级比自己低就提高它的优先级，并且如果这个锁还被别的锁锁着， 将会递归地捐赠优先级， 然后在这个线程释放掉这个锁之后恢复未捐赠逻辑下的优先级。</p>
<p>2. 如果一个线程被多个线程捐赠， 维持当前优先级为捐赠优先级中的最大值（acquire和release之时）。</p>
<p>3. 在对一个线程进行优先级设置的时候， 如果这个线程处于被捐赠状态， 则对original_priority进行设置， 然后如果设置的优先级大于当前优先级， 则改变当前优先级， 否则在捐赠状态取消的时候恢复original_priority。</p>
<p>4. 在释放锁对一个锁优先级有改变的时候应考虑其余被捐赠优先级和当前优先级。</p>
<p>5. 将信号量的等待队列实现为优先级队列。</p>
<p>6. 将condition的waiters队列实现为优先级队列。</p>
<p>7. 释放锁的时候若优先级改变则可以发生抢占。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">具体代码实现：</span></strong></p>
<p>先修改thread数据结构， 加入以下成员：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>     <span style="color: #0000ff;">int</span> base_priority;                  <span style="color: #008000;">/*</span><span style="color: #008000;"> Base priority. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span>     <span style="color: #0000ff;">struct</span> list locks;                  <span style="color: #008000;">/*</span><span style="color: #008000;"> Locks that the thread is holding. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">3</span>     <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *lock_waiting;          <span style="color: #008000;">/*</span><span style="color: #008000;"> The lock that the thread is waiting for. </span><span style="color: #008000;">*/</span></pre>
</div>
<p>然后给lock加一下成员：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>     <span style="color: #0000ff;">struct</span> list_elem elem;      <span style="color: #008000;">/*</span><span style="color: #008000;"> List element for priority donation. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span>     <span style="color: #0000ff;">int</span> max_priority;          <span style="color: #008000;">/*</span><span style="color: #008000;"> Max priority among the threads acquiring the lock. </span><span style="color: #008000;">*/</span></pre>
</div>
<p>好， 数据结构只需要增加这些就可以满足我们的需要了， 开写。</p>
<p>先修改lock_acquire函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> lock_acquire (<span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">struct</span> thread *current_thread =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #000000;">l;
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level old_level;
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   ASSERT (<span style="color: #0000ff;">lock</span> !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;"> 9</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;">10</span>   ASSERT (!lock_held_by_current_thread (<span style="color: #0000ff;">lock</span><span style="color: #000000;">));
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>   <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">lock</span>-&gt;holder != NULL &amp;&amp; !<span style="color: #000000;">thread_mlfqs)
</span><span style="color: #008080;">13</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">14</span>     current_thread-&gt;lock_waiting = <span style="color: #0000ff;">lock</span><span style="color: #000000;">;
</span><span style="color: #008080;">15</span>     l = <span style="color: #0000ff;">lock</span><span style="color: #000000;">;
</span><span style="color: #008080;">16</span>     <span style="color: #0000ff;">while</span> (l &amp;&amp; current_thread-&gt;priority &gt; l-&gt;<span style="color: #000000;">max_priority)
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">18</span>       l-&gt;max_priority = current_thread-&gt;<span style="color: #000000;">priority;
</span><span style="color: #008080;">19</span>       thread_donate_priority (l-&gt;<span style="color: #000000;">holder);
</span><span style="color: #008080;">20</span>       l = l-&gt;holder-&gt;<span style="color: #000000;">lock_waiting;
</span><span style="color: #008080;">21</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">22</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">23</span> 
<span style="color: #008080;">24</span>   sema_down (&amp;<span style="color: #0000ff;">lock</span>-&gt;<span style="color: #000000;">semaphore);
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span>   old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span>   current_thread =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;">29</span>   <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">thread_mlfqs)
</span><span style="color: #008080;">30</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">31</span>     current_thread-&gt;lock_waiting =<span style="color: #000000;"> NULL;
</span><span style="color: #008080;">32</span>     <span style="color: #0000ff;">lock</span>-&gt;max_priority = current_thread-&gt;<span style="color: #000000;">priority;
</span><span style="color: #008080;">33</span>     thread_hold_the_lock (<span style="color: #0000ff;">lock</span><span style="color: #000000;">);
</span><span style="color: #008080;">34</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">35</span>   <span style="color: #0000ff;">lock</span>-&gt;holder =<span style="color: #000000;"> current_thread;
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">38</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>在P操作之前递归地实现优先级捐赠， 然后在被唤醒之后（此时这个线程已经拥有了这个锁），成为这个锁的拥有者。</p>
<p>这里thread_donate_priority和thread_hold_the_lock封装成函数，注意一下这里优先级捐赠是通过直接修改锁的最高优先级， 然后调用update的时候把现成优先级更新实现的，update下面会写， 实现如下：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Let thread hold a lock </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> thread_hold_the_lock(<span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;"> 6</span>   list_insert_ordered (&amp;thread_current ()-&gt;locks, &amp;<span style="color: #0000ff;">lock</span>-&gt;<span style="color: #000000;">elem, lock_cmp_priority, NULL);
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">lock</span>-&gt;max_priority &gt; thread_current ()-&gt;<span style="color: #000000;">priority)
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">10</span>     thread_current ()-&gt;priority = <span style="color: #0000ff;">lock</span>-&gt;<span style="color: #000000;">max_priority;
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    thread_yield ();
</span><span style="color: #008080;">12</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">15</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Donate current priority to thread t. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> thread_donate_priority (<span style="color: #0000ff;">struct</span> thread *<span style="color: #000000;">t)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  thread_update_priority (t);
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">if</span> (t-&gt;status ==<span style="color: #000000;"> THREAD_READY)
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">10</span>     list_remove (&amp;t-&gt;<span style="color: #000000;">elem);
</span><span style="color: #008080;">11</span>     list_insert_ordered (&amp;ready_list, &amp;t-&gt;<span style="color: #000000;">elem, thread_cmp_priority, NULL);
</span><span style="color: #008080;">12</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">13</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">14</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>锁队列排序函数lock_cmp_priority:</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> lock comparation function </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">3</span> lock_cmp_priority (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> list_elem *a, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> list_elem *b, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED)
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">return</span> list_entry (a, <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span>, elem)-&gt;max_priority &gt; list_entry (b, <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span>, elem)-&gt;<span style="color: #000000;">max_priority;
</span><span style="color: #008080;">6</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后在lock_release函数加入以下语句：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">thread_mlfqs)
</span><span style="color: #008080;">2</span>     thread_remove_lock (<span style="color: #0000ff;">lock</span>);</pre>
</div>
<p>thread_remove_lock实现如下：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Remove a lock. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">3</span> thread_remove_lock (<span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span><span style="color: #000000;">)
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">6</span>   list_remove (&amp;<span style="color: #0000ff;">lock</span>-&gt;<span style="color: #000000;">elem);
</span><span style="color: #008080;">7</span> <span style="color: #000000;">  thread_update_priority (thread_current ());
</span><span style="color: #008080;">8</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">9</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>当释放掉一个锁的时候， 当前线程的优先级可能发生变化， 我们用thread_update_priority来处理这个逻辑：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Update priority. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> thread_update_priority (<span style="color: #0000ff;">struct</span> thread *<span style="color: #000000;">t)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">int</span> max_priority = t-&gt;<span style="color: #000000;">base_priority;
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">int</span><span style="color: #000000;"> lock_priority;
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">if</span> (!list_empty (&amp;t-&gt;<span style="color: #000000;">locks))
</span><span style="color: #008080;">10</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">11</span>     list_sort (&amp;t-&gt;<span style="color: #000000;">locks, lock_cmp_priority, NULL);
</span><span style="color: #008080;">12</span>     lock_priority = list_entry (list_front (&amp;t-&gt;locks), <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span>, elem)-&gt;<span style="color: #000000;">max_priority;
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">if</span> (lock_priority &gt;<span style="color: #000000;"> max_priority)
</span><span style="color: #008080;">14</span>       max_priority =<span style="color: #000000;"> lock_priority;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span>   t-&gt;priority =<span style="color: #000000;"> max_priority;
</span><span style="color: #008080;">18</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">19</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里如果这个线程还有锁， 就先获取这个线程拥有锁的最大优先级（可能被更高级线程捐赠）， 然后如果这个优先级比base_priority大的话更新的应该是被捐赠的优先级。</p>
<p>&nbsp;然后在init_thread中加入初始化：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   t-&gt;base_priority =<span style="color: #000000;"> priority;
</span><span style="color: #008080;">2</span>   list_init (&amp;t-&gt;<span style="color: #000000;">locks);
</span><span style="color: #008080;">3</span>   t-&gt;lock_waiting = NULL;</pre>
</div>
<p>修改一下thread_set_priority：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> thread_set_priority (<span style="color: #0000ff;">int</span><span style="color: #000000;"> new_priority)
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">if</span><span style="color: #000000;"> (thread_mlfqs)
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">enum</span> intr_level old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">struct</span> thread *current_thread =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;">10</span>   <span style="color: #0000ff;">int</span> old_priority = current_thread-&gt;<span style="color: #000000;">priority;
</span><span style="color: #008080;">11</span>   current_thread-&gt;base_priority =<span style="color: #000000;"> new_priority;
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   <span style="color: #0000ff;">if</span> (list_empty (&amp;current_thread-&gt;<span style="color: #000000;">locks) || new_priority &gt; old_priority)
</span><span style="color: #008080;">14</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">15</span>     current_thread-&gt;priority =<span style="color: #000000;"> new_priority;
</span><span style="color: #008080;">16</span> <span style="color: #000000;">    thread_yield ();
</span><span style="color: #008080;">17</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">20</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>好， 至此整个捐赠的逻辑都写完了， 还差两个优先级队列的实现， 搞起～</p>
<p>然后把condition的队列改成优先级队列， 修改如下， 修改cond_signal函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> cond_signal (<span style="color: #0000ff;">struct</span> condition *cond, <span style="color: #0000ff;">struct</span> <span style="color: #0000ff;">lock</span> *<span style="color: #0000ff;">lock</span><span style="color: #000000;"> UNUSED)
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   ASSERT (cond !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;"> 5</span>   ASSERT (<span style="color: #0000ff;">lock</span> !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;"> 6</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;"> 7</span>   ASSERT (lock_held_by_current_thread (<span style="color: #0000ff;">lock</span><span style="color: #000000;">));
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">if</span> (!list_empty (&amp;cond-&gt;<span style="color: #000000;">waiters))
</span><span style="color: #008080;">10</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">11</span>     list_sort (&amp;cond-&gt;<span style="color: #000000;">waiters, cond_sema_cmp_priority, NULL);
</span><span style="color: #008080;">12</span>     sema_up (&amp;list_entry (list_pop_front (&amp;cond-&gt;waiters), <span style="color: #0000ff;">struct</span> semaphore_elem, elem)-&gt;<span style="color: #000000;">semaphore);
</span><span style="color: #008080;">13</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">14</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>比较函数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> cond sema comparation function </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">3</span> cond_sema_cmp_priority (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> list_elem *a, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> list_elem *b, <span style="color: #0000ff;">void</span> *<span style="color: #000000;">aux UNUSED)
</span><span style="color: #008080;">4</span> <span style="color: #000000;">{
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">struct</span> semaphore_elem *sa = list_entry (a, <span style="color: #0000ff;">struct</span><span style="color: #000000;"> semaphore_elem, elem);
</span><span style="color: #008080;">6</span>   <span style="color: #0000ff;">struct</span> semaphore_elem *sb = list_entry (b, <span style="color: #0000ff;">struct</span><span style="color: #000000;"> semaphore_elem, elem);
</span><span style="color: #008080;">7</span>   <span style="color: #0000ff;">return</span> list_entry(list_front(&amp;sa-&gt;semaphore.waiters), <span style="color: #0000ff;">struct</span> thread, elem)-&gt;priority &gt; list_entry(list_front(&amp;sb-&gt;semaphore.waiters), <span style="color: #0000ff;">struct</span> thread, elem)-&gt;<span style="color: #000000;">priority;
</span><span style="color: #008080;">8</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后把信号量的等待队列实现为优先级队列：</p>
<p>修改sema_up：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> sema_up (<span style="color: #0000ff;">struct</span> semaphore *<span style="color: #000000;">sema)
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level old_level;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   ASSERT (sema !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">if</span> (!list_empty (&amp;sema-&gt;<span style="color: #000000;">waiters))
</span><span style="color: #008080;">10</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">11</span>     list_sort (&amp;sema-&gt;<span style="color: #000000;">waiters, thread_cmp_priority, NULL);
</span><span style="color: #008080;">12</span>     thread_unblock (list_entry (list_pop_front (&amp;sema-&gt;waiters), <span style="color: #0000ff;">struct</span><span style="color: #000000;"> thread, elem));
</span><span style="color: #008080;">13</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>   sema-&gt;value++<span style="color: #000000;">;
</span><span style="color: #008080;">16</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;">17</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">18</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>修改sema_down：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 2</span> sema_down (<span style="color: #0000ff;">struct</span> semaphore *<span style="color: #000000;">sema)
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">enum</span><span style="color: #000000;"> intr_level old_level;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   ASSERT (sema !=<span style="color: #000000;"> NULL);
</span><span style="color: #008080;"> 7</span>   ASSERT (!<span style="color: #000000;">intr_context ());
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>   old_level =<span style="color: #000000;"> intr_disable ();
</span><span style="color: #008080;">10</span>   <span style="color: #0000ff;">while</span> (sema-&gt;value == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">12</span>       list_insert_ordered (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;<span style="color: #000000;">elem, thread_cmp_priority, NULL);
</span><span style="color: #008080;">13</span> <span style="color: #000000;">      thread_block ();
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">15</span>   sema-&gt;value--<span style="color: #000000;">;
</span><span style="color: #008080;">16</span> <span style="color: #000000;">  intr_set_level (old_level);
</span><span style="color: #008080;">17</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>好， 做完这些其实是一气呵成的， 因为之前多测试需求有足够多的分析了， 来看测试结果：</p>
<p>&nbsp;<img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/271354306467599.png" alt=""></p>
<p>&nbsp;毫无悬念地过了， 至此mission2完成，撒个花， 看个B站继续搞mission3~</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>Mission3:</strong></span></p>
<p><span style="font-size: 14pt; color: #ff0000;">实现多级反馈调度（2.2.4）（</span><span style="color: #ff0000;">Advanced Scheduler or 4.4BSD&nbsp;Scheduler</span><span style="font-size: 14pt; color: #ff0000;">）</span></p>
<p><strong>&nbsp;作用： 减少系统平均响应时间。</strong></p>
<p>在这个mission中我们需要把mlfqs*给过了， 完成之后实验一的所有测试就pass了～</p>
<p>实验具体描述（必读）：&nbsp;http://www.ccs.neu.edu/home/amislove/teaching/cs5600/fall10/pintos/pintos_7.html</p>
<blockquote>
<p>Every thread has a&nbsp;<var>nice</var>&nbsp;value between -20 and 20 directly under its control. Each thread also has a priority, between 0 (<code>PRI_MIN</code>) through 63 (<code>PRI_MAX</code>), which is recalculated using the following formula every fourth tick:</p>
<p>&nbsp;</p>
<center><tt><var>priority</var>&nbsp;=&nbsp;<code>PRI_MAX</code>&nbsp;- (<var>recent_cpu</var>&nbsp;/ 4) - (<var>nice</var>&nbsp;* 2)</tt>.</center>
<p>&nbsp;</p>
<p><var>recent_cpu</var>&nbsp;measures the amount of CPU time a thread has received "recently." On each timer tick, the running thread's&nbsp;<var>recent_cpu</var>&nbsp;is incremented by 1. Once per second, every thread's&nbsp;<var>recent_cpu</var>&nbsp;is updated this way:</p>
<p>&nbsp;</p>
<center><tt><var>recent_cpu</var>&nbsp;= (2*<var>load_avg</var>)/(2*<var>load_avg</var>&nbsp;+ 1) *&nbsp;<var>recent_cpu</var>&nbsp;+&nbsp;<var>nice</var></tt>.</center>
<p>&nbsp;</p>
<p><var>load_avg</var>&nbsp;estimates the average number of threads ready to run over the past minute. It is initialized to 0 at boot and recalculated once per second as follows:</p>
<p>&nbsp;</p>
<center><tt><var>load_avg</var>&nbsp;= (59/60)*<var>load_avg</var>&nbsp;+ (1/60)*<var>ready_threads</var></tt>.</center>
<p>&nbsp;</p>
<p>where&nbsp;<var>ready_threads</var>&nbsp;is the number of threads that are either running or ready to run at time of update (not including the idle thread).</p>
</blockquote>
<p>简单来说这里是维持了64个队列， 每个队列对应一个优先级， 从PRI_MIN到PRI_MAX。</p>
<p>然后<span style="color: #ff0000;">通过一些公式计算来计算出线程当前的优先级</span>， 系统调度的时候会从高优先级队列开始选择线程执行， 这里<span style="color: #ff0000;">线程的优先级随着操作系统的运转数据而动态改变。</span></p>
<p>然后这个计算又涉及到了浮点数运算的问题， pintos本身并没有实现这个， 需要我们自己来搞。</p>
<blockquote>
<p><span style="font-size: 15px;">The following table summarizes how fixed-point arithmetic operations can be implemented in C. In the table,&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>&nbsp;are fixed-point numbers,&nbsp;<code>n</code>is an integer, fixed-point numbers are in signed p.q format where p + q = 31, and&nbsp;<code>f</code>&nbsp;is&nbsp;<code>1 &lt;&lt; q：</code></span><span style="font-size: 15px;">&nbsp;</span></p>
<center>
<table>
<tbody>
<tr>
<td><span style="font-size: 15px;">Convert&nbsp;<code>n</code>&nbsp;to fixed point:</span></td>
<td><span style="font-size: 15px;"><code>n * f</code></span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">Convert&nbsp;<code>x</code>&nbsp;to integer (rounding toward zero):</span></td>
<td><span style="font-size: 15px;"><code>x / f</code></span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">Convert&nbsp;<code>x</code>&nbsp;to integer (rounding to nearest):</span></td>
<td><span style="font-size: 15px;"><code>(x + f / 2) / f</code>&nbsp;if&nbsp;<code>x &gt;= 0</code>,&nbsp;</span><br><span style="font-size: 15px;"><code>(x - f / 2) / f</code>&nbsp;if&nbsp;<code>x &lt;= 0</code>.</span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Add&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>:</span></td>
<td><span style="font-size: 15px;"><code>x + y</code></span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Subtract&nbsp;<code>y</code>&nbsp;from&nbsp;<code>x</code>:</span></td>
<td><span style="font-size: 15px;"><code>x - y</code></span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Add&nbsp;<code>x</code>&nbsp;and&nbsp;<code>n</code>:</span></td>
<td><span style="font-size: 15px;"><code>x + n * f</code></span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Subtract&nbsp;<code>n</code>&nbsp;from&nbsp;<code>x</code>:</span></td>
<td><span style="font-size: 15px;"><code>x - n * f</code></span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Multiply&nbsp;<code>x</code>&nbsp;by&nbsp;<code>y</code>:</span></td>
<td><span style="font-size: 15px;"><code>((int64_t) x) * y / f</code></span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Multiply&nbsp;<code>x</code>&nbsp;by&nbsp;<code>n</code>:</span></td>
<td><span style="font-size: 15px;"><code>x * n</code></span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Divide&nbsp;<code>x</code>&nbsp;by&nbsp;<code>y</code>:</span></td>
<td><span style="font-size: 15px;"><code>((int64_t) x) * f / y</code></span></td>

















</tr>
<tr>
<td><span style="font-size: 15px;">Divide&nbsp;<code>x</code>&nbsp;by&nbsp;<code>n</code>:</span></td>
<td><span style="font-size: 15px;"><code>x / n</code></span></td>

















</tr>

















</tbody>

















</table>

















</center></blockquote>
<p><span style="line-height: 1.5;">实现思路：<span style="color: #ff0000;"> 在timer_interrupt中固定一段时间计算更新线程的优先级，这里是每TIMER_FREQ时间更新一次系统load_avg和所有线程的recent_cpu， 每4个timer_ticks更新一次线程优先级， 每个timer_tick running线程的recent_cpu加一， 虽然这里说的是维持64个优先级队列调度， 其本质还是优先级调度， 我们保留之前写的优先级调度代码即可， 去掉优先级捐赠（之前donate相关代码已经对需要的地方加了thread_mlfqs的判断了）。</span></span></p>
<p>浮点运算逻辑实现在fixed_point.h中：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #000000;">#ifndef __THREAD_FIXED_POINT_H
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">#define</span> __THREAD_FIXED_POINT_H
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Basic definitions of fixed point. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 5</span> typedef <span style="color: #0000ff;">int</span><span style="color: #000000;"> fixed_t;
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 16 LSB used for fractional part. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span> <span style="color: #0000ff;">#define</span> FP_SHIFT_AMOUNT 16
<span style="color: #008080;"> 8</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Convert a value to fixed-point value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">#define</span> FP_CONST(A) ((fixed_t)(A &lt;&lt; FP_SHIFT_AMOUNT))
<span style="color: #008080;">10</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Add two fixed-point value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span> <span style="color: #0000ff;">#define</span> FP_ADD(A,B) (A + B)
<span style="color: #008080;">12</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Add a fixed-point value A and an int value B. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">#define</span> FP_ADD_MIX(A,B) (A + (B &lt;&lt; FP_SHIFT_AMOUNT))
<span style="color: #008080;">14</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Substract two fixed-point value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">15</span> <span style="color: #0000ff;">#define</span> FP_SUB(A,B) (A - B)
<span style="color: #008080;">16</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Substract an int value B from a fixed-point value A </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">17</span> <span style="color: #0000ff;">#define</span> FP_SUB_MIX(A,B) (A - (B &lt;&lt; FP_SHIFT_AMOUNT))
<span style="color: #008080;">18</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Multiply a fixed-point value A by an int value B. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">19</span> <span style="color: #0000ff;">#define</span> FP_MULT_MIX(A,B) (A * B)
<span style="color: #008080;">20</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Divide a fixed-point value A by an int value B. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">21</span> <span style="color: #0000ff;">#define</span> FP_DIV_MIX(A,B) (A / B)
<span style="color: #008080;">22</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Multiply two fixed-point value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">23</span> <span style="color: #0000ff;">#define</span> FP_MULT(A,B) ((fixed_t)(((int64_t) A) * B &gt;&gt; FP_SHIFT_AMOUNT))
<span style="color: #008080;">24</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Divide two fixed-point value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">25</span> <span style="color: #0000ff;">#define</span> FP_DIV(A,B) ((fixed_t)((((int64_t) A) &lt;&lt; FP_SHIFT_AMOUNT) / B))
<span style="color: #008080;">26</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Get integer part of a fixed-point value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">27</span> <span style="color: #0000ff;">#define</span> FP_INT_PART(A) (A &gt;&gt; FP_SHIFT_AMOUNT)
<span style="color: #008080;">28</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Get rounded integer of a fixed-point value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">29</span> <span style="color: #0000ff;">#define</span> FP_ROUND(A) (A &gt;= 0 ? ((A + (1 &lt;&lt; (FP_SHIFT_AMOUNT - 1))) &gt;&gt; FP_SHIFT_AMOUNT) \
<span style="color: #008080;">30</span>         : ((A - (<span style="color: #800080;">1</span> &lt;&lt; (FP_SHIFT_AMOUNT - <span style="color: #800080;">1</span>))) &gt;&gt;<span style="color: #000000;"> FP_SHIFT_AMOUNT))
</span><span style="color: #008080;">31</span> 
<span style="color: #008080;">32</span> <span style="color: #0000ff;">#endif</span> /* thread/fixed_point.h */</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;注意一下这里的实现， 这里用16位数（FP_SHIFT_AMOUNT）作为浮点数的小数部分， 理解了这点就很容易看了， 注意一点是无论什么运算一定要维持整数部分从第17位开始就行。</p>
<p>先实现timer_interrupt的逻辑，加入以下代码：&nbsp;</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span>   <span style="color: #0000ff;">if</span><span style="color: #000000;"> (thread_mlfqs)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">3</span> <span style="color: #000000;">    thread_mlfqs_increase_recent_cpu_by_one ();
</span><span style="color: #008080;">4</span>     <span style="color: #0000ff;">if</span> (ticks % TIMER_FREQ == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">5</span> <span style="color: #000000;">      thread_mlfqs_update_load_avg_and_recent_cpu ();
</span><span style="color: #008080;">6</span>     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (ticks % <span style="color: #800080;">4</span> == <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">7</span> <span style="color: #000000;">      thread_mlfqs_update_priority (thread_current ());
</span><span style="color: #008080;">8</span>   }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后填一下这里挖的坑：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Increase recent_cpu by 1. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> thread_mlfqs_increase_recent_cpu_by_one (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">  ASSERT (thread_mlfqs);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  ASSERT (intr_context ());
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">struct</span> thread *current_thread =<span style="color: #000000;"> thread_current ();
</span><span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">if</span> (current_thread ==<span style="color: #000000;"> idle_thread)
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">11</span>   current_thread-&gt;recent_cpu = FP_ADD_MIX (current_thread-&gt;recent_cpu, <span style="color: #800080;">1</span><span style="color: #000000;">);
</span><span style="color: #008080;">12</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>注意这里调用的运算都是浮点运算。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Every per second to refresh load_avg and recent_cpu of all threads. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> thread_mlfqs_update_load_avg_and_recent_cpu (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">  ASSERT (thread_mlfqs);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  ASSERT (intr_context ());
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>   size_t ready_threads = list_size (&amp;<span style="color: #000000;">ready_list);
</span><span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">if</span> (thread_current () !=<span style="color: #000000;"> idle_thread)
</span><span style="color: #008080;">10</span>     ready_threads++<span style="color: #000000;">;
</span><span style="color: #008080;">11</span>   load_avg = FP_ADD (FP_DIV_MIX (FP_MULT_MIX (load_avg, <span style="color: #800080;">59</span>), <span style="color: #800080;">60</span>), FP_DIV_MIX (FP_CONST (ready_threads), <span style="color: #800080;">60</span><span style="color: #000000;">));
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   <span style="color: #0000ff;">struct</span> thread *<span style="color: #000000;">t;
</span><span style="color: #008080;">14</span>   <span style="color: #0000ff;">struct</span> list_elem *e = list_begin (&amp;<span style="color: #000000;">all_list);
</span><span style="color: #008080;">15</span>   <span style="color: #0000ff;">for</span> (; e != list_end (&amp;all_list); e =<span style="color: #000000;"> list_next (e))
</span><span style="color: #008080;">16</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">17</span>     t = list_entry(e, <span style="color: #0000ff;">struct</span><span style="color: #000000;"> thread, allelem);
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">if</span> (t !=<span style="color: #000000;"> idle_thread)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">20</span>       t-&gt;recent_cpu = FP_ADD_MIX (FP_MULT (FP_DIV (FP_MULT_MIX (load_avg, <span style="color: #800080;">2</span>), FP_ADD_MIX (FP_MULT_MIX (load_avg, <span style="color: #800080;">2</span>), <span style="color: #800080;">1</span>)), t-&gt;recent_cpu), t-&gt;<span style="color: #000000;">nice);
</span><span style="color: #008080;">21</span> <span style="color: #000000;">      thread_mlfqs_update_priority (t);
</span><span style="color: #008080;">22</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">23</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">24</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>这里的大部分逻辑都是Project给好的算数运算逻辑， 真正的行为逻辑并不复杂， 再填最后一个坑：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Update priority. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> thread_mlfqs_update_priority (<span style="color: #0000ff;">struct</span> thread *<span style="color: #000000;">t)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">if</span> (t ==<span style="color: #000000;"> idle_thread)
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> <span style="color: #000000;">  ASSERT (thread_mlfqs);
</span><span style="color: #008080;"> 9</span>   ASSERT (t !=<span style="color: #000000;"> idle_thread);
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>   t-&gt;priority = FP_INT_PART (FP_SUB_MIX (FP_SUB (FP_CONST (PRI_MAX), FP_DIV_MIX (t-&gt;recent_cpu, <span style="color: #800080;">4</span>)), <span style="color: #800080;">2</span> * t-&gt;<span style="color: #000000;">nice));
</span><span style="color: #008080;">12</span>   t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;<span style="color: #000000;">priority;
</span><span style="color: #008080;">13</span>   t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;<span style="color: #000000;">priority;
</span><span style="color: #008080;">14</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>好， 把这个3个坑给填了之后我们mission3的主体逻辑就已经完成了。</p>
<p>然后处理一些细节改动， thread结构体加入以下成员：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>     <span style="color: #0000ff;">int</span> nice;                           <span style="color: #008000;">/*</span><span style="color: #008000;"> Niceness. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">2</span>     fixed_t recent_cpu;                 <span style="color: #008000;">/*</span><span style="color: #008000;"> Recent CPU. </span><span style="color: #008000;">*/</span></pre>
</div>
<p>线程初始化的时候初始化这两个新的成员， 在init_thread中加入这些代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   t-&gt;nice = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">2</span>   t-&gt;recent_cpu = FP_CONST (<span style="color: #800080;">0</span>);</pre>
</div>
<p>然后填一下这个系统给你挖好的坑：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Sets the current thread's nice value to NICE. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span> thread_set_nice (<span style="color: #0000ff;">int</span><span style="color: #000000;"> nice)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   thread_current ()-&gt;nice =<span style="color: #000000;"> nice;
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  thread_mlfqs_update_priority (thread_current ());
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">  thread_yield ();
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns the current thread's nice value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">11</span> <span style="color: #0000ff;">int</span>
<span style="color: #008080;">12</span> thread_get_nice (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;">13</span> <span style="color: #000000;">{
</span><span style="color: #008080;">14</span>   <span style="color: #0000ff;">return</span> thread_current ()-&gt;<span style="color: #000000;">nice;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">}
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns 100 times the system load average. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">18</span> <span style="color: #0000ff;">int</span>
<span style="color: #008080;">19</span> thread_get_load_avg (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;">20</span> <span style="color: #000000;">{
</span><span style="color: #008080;">21</span>   <span style="color: #0000ff;">return</span> FP_ROUND (FP_MULT_MIX (load_avg, <span style="color: #800080;">100</span><span style="color: #000000;">));
</span><span style="color: #008080;">22</span> <span style="color: #000000;">}
</span><span style="color: #008080;">23</span> 
<span style="color: #008080;">24</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> Returns 100 times the current thread's recent_cpu value. </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">25</span> <span style="color: #0000ff;">int</span>
<span style="color: #008080;">26</span> thread_get_recent_cpu (<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;">27</span> <span style="color: #000000;">{
</span><span style="color: #008080;">28</span>   <span style="color: #0000ff;">return</span> FP_ROUND (FP_MULT_MIX (thread_current ()-&gt;recent_cpu, <span style="color: #800080;">100</span><span style="color: #000000;">));
</span><span style="color: #008080;">29</span> <span style="color: #000000;">}
</span><span style="color: #008080;">30</span> </pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>然后在thread.c中加入全局变量：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> fixed_t load_avg;</pre>
</div>
<p>并在thread_start中初始化：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   load_avg = FP_CONST (<span style="color: #800080;">0</span>);</pre>
</div>
<p>好， 所有的坑都填完了， 跑一下测试：</p>
<p>&nbsp;<img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/281409329585583.jpg" alt=""></p>
<p><span style="line-height: 1.5;">&nbsp;看到这 “All 27 tests passed.” 还是挺激动的哈哈~</span></p>
<p>&nbsp;</p>
<p><strong>ok， 至此这个project1就全部完成了， 难度还是有的， 特别在优先级调度这个mission上。</strong></p>
<p><strong>历时差不多一周， 从开始做这个东西。</strong></p>
<p><strong>完结撒花。</strong></p>
<p><strong>谢谢。</strong></p>
<p>&nbsp;<img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/281416420521693.jpg" alt=""></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag">标签: <a href="http://www.cnblogs.com/laiy/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div>
<div id="blog_post_info"><div id="green_channel">
绿色通道：
<a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(4437768,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
<a id="green_channel_follow" onclick="c_follow();" href="javascript:void(0);">关注我</a>
<a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a><a id="green_channel_contact" href="http://space.cnblogs.com/msg/send/laiy" target="_blank">与我联系</a>
<a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/icon_weibo_24.png" alt=""></a>
</div>
<div id="author_profile">
<div id="author_profile_info" class="author_profile_info">
<a href="http://home.cnblogs.com/u/laiy/" target="_blank"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/20150422103054.png" class="author_avatar" alt=""></a>
<div id="author_profile_detail" class="author_profile_info">
<a href="http://home.cnblogs.com/u/laiy/">laiy</a><br>
<a href="http://home.cnblogs.com/u/laiy/followees">关注 - 1</a><br>
<a href="http://home.cnblogs.com/u/laiy/followers">粉丝 - 8</a>
</div>
</div>
<div class="clear"></div>
<div id="author_profile_honor"></div>
<div id="author_profile_follow">
    <a href="javascript:void(0);" onclick="c_follow();return false;">+加关注</a>
</div>
</div>
<div id="div_digg">										
    <div class="diggit" onclick="votePost(4437768,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">5</span>
    </div>
	<div class="buryit" onclick="votePost(4437768,&#39;Bury&#39;)"> 
		<span class="burynum" id="bury_count">0</span>
	</div>
	<div class="clear"></div>	
	<div class="diggword" id="digg_tips">
    (请您对文章做出评价)
    </div>	
</div>
</div>
<div class="clear"></div>
<div id="post_next_prev"><a href="http://www.cnblogs.com/laiy/p/4365226.html" class="p_n_p_prefix">« </a> 上一篇：<a href="http://www.cnblogs.com/laiy/p/4365226.html" title="发布于2015-03-25 11:55">算法模版：非递归快速幂算法详解</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2015-04-28 14:40</span> <a href="http://www.cnblogs.com/laiy/">laiy</a> 阅读(<span id="post_view_count">2675</span>) 评论(<span id="post_comment_count">2</span>)  <a href="http://i.cnblogs.com/EditPosts.aspx?postid=4437768" rel="nofollow">编辑</a> <a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#" onclick="AddToWz(4437768);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,isLogined=false,cb_blogId=203185,cb_entryId=4437768,cb_blogApp=currentBlogApp,cb_blogUserGuid='e99f86bc-2060-e411-b908-9dcfd8948a71',cb_entryCreatedDate='2015/4/28 14:40:00';loadViewCount(cb_entryId);</script>
	
</div><!--end: topics 文章、评论容器-->
<a name="!comments"></a><div id="blog-comments-placeholder"><div id="comments_pager_top"></div>
<br>
<div class="feedback_area_title">评论列表</div>
<div class="feedbackNoItems"></div>	

		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#3175180" class="layer">#1楼</a><a name="3175180" id="comment_anchor_3175180"></a>  <span class="comment_date">2015-05-03 23:40</span> <a id="a_comment_author_3175180" href="http://home.cnblogs.com/u/696392/" target="_blank">ccccly</a> <a href="http://msg.cnblogs.com/msg/send/ccccly" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3175180" class="blog_comment_body">谢谢~帮大忙了，研究了一晚上的pintos^_^</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3175180,&#39;Digg&#39;,this)">支持(1)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3175180,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#3175617" class="layer">#2楼</a><a name="3175617" id="comment_anchor_3175617"></a>[<span class="louzhu">楼主</span>]<span id="comment-maxId" style="display:none;">3175617</span><span id="comment-maxDate" style="display:none;">2015/5/4 15:16:16</span>  <span class="comment_date">2015-05-04 15:16</span> <a id="a_comment_author_3175617" href="http://www.cnblogs.com/laiy/" target="_blank">laiy</a> <a href="http://msg.cnblogs.com/msg/send/laiy" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3175617" class="blog_comment_body"><a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#3175180" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3175180);">@</a>ccccly<br>With pleasure.</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3175617,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3175617,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3175617_avatar" style="display:none;">http://pic.cnblogs.com/face/687472/20150422103054.png</span>
			</div>
		</div>
	<div id="comments_pager_bottom"></div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#" onclick="return RefreshPage();">刷新页面</a><a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></div>
<div id="opt_under_post"></div>
<script type="text/javascript">
    var enableGoogleAd = canShowAdsense(); var googletag = googletag || {}; googletag.cmd = googletag.cmd || [];
    fixPostBodyFormat();
</script>
<div id="ad_under_post_holder">
<script type="text/javascript">
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
    })();
</script>
<script type="text/javascript">
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function () {
                googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1346480159711-0').addService(googletag.pubads());
                googletag.defineSlot('/1090369/cnblogs_blogpost_C2', [468, 60], 'div-gpt-ad-1410860226396-0').addService(googletag.pubads());
                googletag.pubads().enableSingleRequest();
                googletag.enableServices();
            });
        };
    } catch (e) { }
</script>
<div id="google_ad_c1" class="c_ad_block">
    <div id="div-gpt-ad-1346480159711-0" style="width:300px; height:250px;">
    <script type="text/javascript">
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1346480159711-0'); });            
            } else {
                $('#div-gpt-ad-1346480159711-0').hide();
            }
    } catch (e) { }
    </script>
    </div>
</div>
</div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>最新IT新闻</b>:<br> ·  <a href="http://news.cnblogs.com/n/521423/" target="_blank">三星：S6/S6 edge一个月销量就破千万</a><br> ·  <a href="http://news.cnblogs.com/n/521422/" target="_blank">苹果手表系统首次升级</a><br> ·  <a href="http://news.cnblogs.com/n/521421/" target="_blank">奇虎360第一季度净利5300万美元 同比增长8%</a><br> ·  <a href="http://news.cnblogs.com/n/521420/" target="_blank">网秦第一季度净亏损1700万美元 同比收窄</a><br> ·  <a href="http://news.cnblogs.com/n/521419/" target="_blank">学大教育第一季度净利90万美元 同比下滑25%</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="google_ad_c2" class="c_ad_block">
<div id="div-gpt-ad-1410860226396-0" style="width:468px; height:60px;">
<script type="text/javascript">
try {
    if (enableGoogleAd) {
        googletag.cmd.push(function () { googletag.display('div-gpt-ad-1410860226396-0'); });
    } else {
        $('#div-gpt-ad-1346480159711-0').hide();
    }
} catch (e) { }
</script>
</div>
</div>
<div id="under_post_kb"><div class="itnews c_ad_block" id="kb_block"><b>最新知识库文章</b>:<br><div id="kb_recent"> ·  <a href="http://kb.cnblogs.com/page/521320/" target="_blank">理想的程序员</a><br> ·  <a href="http://kb.cnblogs.com/page/504915/" target="_blank">大师是怎样炼成的</a><br> ·  <a href="http://kb.cnblogs.com/page/521008/" target="_blank">元数据驱动设计 —— 设计一套用于API数据检索的灵活引擎</a><br> ·  <a href="http://kb.cnblogs.com/page/147517/" target="_blank">持续部署，并不简单！</a><br> ·  <a href="http://kb.cnblogs.com/page/520961/" target="_blank">如果你做的事情毫不费力，就是在浪费时间</a><br></div>» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
</script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><a href="http://info.flagcounter.com/XQJ3"><img src="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/saved_resource" alt="Flag Counter" border="0"></a><div id="profile_block">昵称：<a href="http://home.cnblogs.com/u/laiy/">laiy</a><br>园龄：<a href="http://home.cnblogs.com/u/laiy/" title="入园时间：2014-10-30">6个月</a><br>粉丝：<a href="http://home.cnblogs.com/u/laiy/followers/">8</a><br>关注：<a href="http://home.cnblogs.com/u/laiy/followees/">1</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="cnblogs.UserManager.FollowBlogger(&#39;e99f86bc-2060-e411-b908-9dcfd8948a71&#39;)">+加关注</a></div></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar"><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="日历">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2015/04/01&#39;);return false;">&lt;</a></td><td align="center">2015年5月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2015/06/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">26</td><td class="CalOtherMonthDay" align="center">27</td><td class="CalOtherMonthDay" align="center">28</td><td class="CalOtherMonthDay" align="center">29</td><td class="CalOtherMonthDay" align="center">30</td><td align="center">1</td><td class="CalWeekendDay" align="center">2</td></tr><tr><td class="CalWeekendDay" align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td class="CalWeekendDay" align="center">9</td></tr><tr><td class="CalWeekendDay" align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td><td class="CalWeekendDay" align="center">16</td></tr><tr><td class="CalWeekendDay" align="center">17</td><td align="center">18</td><td align="center">19</td><td class="CalTodayDay" align="center">20</td><td align="center">21</td><td align="center">22</td><td class="CalWeekendDay" align="center">23</td></tr><tr><td class="CalWeekendDay" align="center">24</td><td align="center">25</td><td align="center">26</td><td align="center">27</td><td align="center">28</td><td align="center">29</td><td class="CalWeekendDay" align="center">30</td></tr><tr><td class="CalWeekendDay" align="center">31</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_categories">
<div id="sidebar_postarchive" class="catListPostArchive sidebar-block">
<h3 class="catListTitle">随笔档案</h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="http://www.cnblogs.com/laiy/archive/2015/04.html">2015年4月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="http://www.cnblogs.com/laiy/archive/2015/03.html">2015年3月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="http://www.cnblogs.com/laiy/archive/2015/01.html">2015年1月 (1)</a> </li>

</ul>

</div>

</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div id="RecentCommentsBlock"><ul>
    <li class="recent_comment_title"><a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#3175617">1. Re:Pintos-斯坦福大学操作系统Project详解-Project1</a></li>
    <li class="recent_comment_body">@cccclyWith pleasure....</li>
    <li class="recent_comment_author">--laiy</li>
    <li class="recent_comment_title"><a href="http://www.cnblogs.com/laiy/p/pintos_project1_thread.html#3175180">2. Re:Pintos-斯坦福大学操作系统Project详解-Project1</a></li>
    <li class="recent_comment_body">谢谢~帮大忙了，研究了一晚上的pintos^_^</li>
    <li class="recent_comment_author">--ccccly</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">推荐排行榜</h3>
<div id="TopDiggPostsBlock"><ul><li><a href="./Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园_files/Pintos-斯坦福大学操作系统Project详解-Project1 - laiy - 博客园.html">1. Pintos-斯坦福大学操作系统Project详解-Project1(5)</a></li><li><a href="http://www.cnblogs.com/laiy/p/KMP_by_LY.html">2. KMP算法详解(1)</a></li></ul></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2015 laiy
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


</body></html>